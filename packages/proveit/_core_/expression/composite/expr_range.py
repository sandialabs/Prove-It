import more_itertools

from proveit._core_.expression.expr import (Expression, MakeNotImplemented,
                                            ImproperReplacement, 
                                            free_vars)
from proveit._core_.expression.style_options import StyleOptions
from proveit._core_.expression.lambda_expr.lambda_expr import Lambda
from proveit._core_.expression.composite import singularExpression, ExprTuple
from proveit._core_.expression.conditional import Conditional
from proveit._core_.proof import ProofFailure
from proveit._core_.defaults import defaults, USE_DEFAULTS

class ExprRange(Expression):
    '''
    An ExprRange expression represents a range of "element" expressions
    within a containing ExprTuple.  It represents this as a Lambda to 
    map each valid index value to a corresponding element, along with a
    start and end index value.  The represented element sequence 
    corresponds to index values going from the start to the end in 
    increments of 1, ranging over index values.
    
    For example,
    1/i + ... + 1/j
    is internall represented by an Add operation with the following as 
    its "operands":
    (1/i, ..., 1/j).
    These "operands" are represented by an ExprTuple with a single 
    "entry" which is an ExprRange whose `lambda_map` is "k |-> 1/k", 
    `start_index` is "i", and `end_index` is "j".  An ExprTuple "entry" 
    may generally either be a singuler element or an ExprRange that 
    represents multiple elements.
    '''

    def __init__(self, parameter, body, start_index, end_index, *,
                 parameterization=None, lambda_map=None):
        '''
        Create an ExprRange that represents a range of expressions
        to be embedded within an ExprTuple.  Each element of the
        range is generated by mapping the parameter according to the
        body with the parameter ranging from the start index to the
        end index. 
        A Lambda expression will be created as its first sub-expression.
        The start and end indices with be the second and third
        sub-expressions.
        
        The 'parameterization' sets the style for formatting the
        ExprRange.  The default is "implicit" for LaTeX formatting
        but "explicit" for string formatting.  Since string formatting
        is most often used for error messages, it is useful to have
        the full "explicit" version.
        
        The lambda_map may be used instead of supplying the parameter 
        and body, in which case the 'parameter' and 'body' arguments
        must both be None.
        '''
        if lambda_map is not None:
            # Use the provided 'lambda_map' instead of creating one.
            lambda_map = lambda_map
            if (parameter, body) != (None, None):
                raise ValueError("'parameter' and 'body' arguments of the "
                                 "ExprRange constructor should be None if "
                                 "lambda_map is provided.")
            parameter = lambda_map.parameter
        else:
            lambda_map = Lambda(parameter, body)
        if parameterization not in (None, 'implicit', 'explicit'):
            raise ValueError("'parameterization' must be 'implicit', "
                             "'explicit', or None; not %s"%parameterization)
        styles = ({'parameterization':parameterization} if
                  parameterization is not None else dict())
        
        Expression.__init__(self, ['ExprRange'], 
                            [lambda_map, start_index, end_index],
                            styles=styles)
        self.start_index = singularExpression(start_index)
        self.end_index = singularExpression(end_index)
        self.lambda_map = lambda_map
        # The body of the Lambda map is a Conditional that conditions the 
        # mapping according to the parameter being in the [start, end] 
        # interval.  We'll use self.body to refer to the value of this
        # conditional.
        self.parameter = self.lambda_map.parameter
        self.body = self.lambda_map.body
        self.is_parameter_independent = (
                self.parameter not in 
                free_vars(self.body, err_inclusively=True))
    
    @classmethod
    def _make(subClass, coreInfo, styles, subExpressions):
        if subClass != ExprRange: 
            MakeNotImplemented(subClass)
        if len(coreInfo) != 1 or coreInfo[0] != 'ExprRange':
            raise ValueError("Expecting ExprRange coreInfo to contain "
                             "exactly one item: 'ExprRange'")
        lambda_map, start_index, end_index = subExpressions
        return ExprRange(None, None, start_index, end_index, 
                         lambda_map=lambda_map) \
                .withStyles(**styles)
    
    def literal_int_extent(self):
        '''
        If the start and end indices of this ExprRange are literal integers,
        return the literal number of elements of the ExprRange.  For the
        case of nested ExprRange's, all of the start and end indices must
        be integers and the result will be the multiplied extent.  For
        example: 
            a_{1,1}, ..., a_{1,3}, ......, a_{4,1}, ..., a_{4,3}
        has a literal_int_extent of 12.
        '''
        from proveit.number import isLiteralInt
        if (isLiteralInt(self.start_index) and isLiteralInt(self.end_index)):
            toplevel_extent = (self.end_index.asInt() - self.start_index.asInt() + 1)
            if isinstance(self.body, ExprRange):
                return toplevel_extent*self.body.literal_int_extent()
            else:
                return toplevel_extent
        raise ValueError("literal_int_extent may only be used on an ExprRange  "
                         "with start and end indices that are literal integers")
        
            
    def remakeArguments(self):
        '''
        Yield the argument values or (name, value) pairs
        that could be used to recreate the ExprRange.
        '''
        yield self.lambda_map.parameter
        yield self.lambda_map.body
        yield self.start_index
        yield self.end_index

    def remakeWithStyleCalls(self):
        '''
        In order to reconstruct this Expression to have the same styles,
        what "with..." method calls are most appropriate?  Return a 
        tuple of strings with the calls to make.  The default for the
        Operation class is to include appropriate 'withWrappingAt'
        and 'withJustification' calls.
        '''
        call_strs = []
        parameterization = self.getStyle('parameterization', 'default')
        if parameterization != 'default':
            if parameterization == 'explicit':
                call_strs.append('withExplicitParameterization()')
            if parameterization == 'implicit':
                call_strs.append('withImplicitParameterization()')
        return call_strs
    
    def styleOptions(self):
        options = StyleOptions(self)
        options.addOption(
                'parameterization', 
                ("'implicit' (default for LaTeX formatting) hides "
                 "the parameter the ExprRange so the parameterization "
                 "may be ambiguous (e.g., x_{1+1}, ..., x_{n+1}); "
                 "'explicit' (default for string formatting) reveals "
                 "the parameterization "
                 "(e.g. x_{1+1}, ..x_{k+1}.., x_{n+1})."))
        return options
    
    def withExplicitParameterization(self):
        '''
        The 'parameterization':'explicit' style shows the 
        parameterization of the ExprRange explicitly.  For example,
        x_{1+1}, ..x_{k+1}.., x_{n+1}).
        '''
        return self.withStyles(parameterization='explicit')

    def withImplicitParameterization(self):
        '''
        The 'parameterization':'implicit' style does not show the
        parameterization of the ExprRange explicitly and such that the
        parameterization may be ambiguous but is more compact.  
        For example, x_{1+1}, ..., x_{n+1} could be
        x_{1+1}, ..x_{k+1}.., x_{n+1}
        or could be
        x_{1+1}, ..x_{k}.., x_{n+1}.
        '''
        return self.withStyles(parameterization='implicit')

    def withDefaultParameterizationStyle(self):
        '''
        The default is to use an 'implicit' parameterization for
        string formatting (see 'withImplicitParameterization') and
        and 'explicit' parameterization for LaTeX formatting
        (see 'withExplicitParameterization').
        '''
        return self.withoutStyle('parameterization')
        
    def first(self):
        '''
        Return the first instance of the range 
        (and store for future use).
        '''
        if not hasattr(self, '_first'):
            expr_map = {self.lambda_map.parameter:self.start_index}
            self._first =  self.body.replaced(expr_map)
        return self._first

    def last(self):
        '''
        Return the last instance of the range 
        (and store for future use).
        '''
        if not hasattr(self, '_last'):
            expr_map = {self.lambda_map.parameter:self.end_index}
            self._last = self.body.replaced(expr_map)
        return self._last
    
    def string(self, **kwargs):
        return self.formatted('string', **kwargs)

    def latex(self, **kwargs):
        return self.formatted('latex', **kwargs)
    
    def nested_range_depth(self):
        '''
        Return the depth of nested ranges.  For example, if this
        is a simple range with no nesting, return 1.
        If this is a range of simple ranges, return 2.
        If this is a range of ranges of simple ranges, return 3.
        '''
        depth = 1
        expr = self.body
        while isinstance(expr, ExprRange):
            depth += 1
            expr = expr.body
        return depth
    
    def _use_explicit_parameterization(self, formatType):
        '''
        Return True iff explicit parameterization should be used
        for the given format type given the 'style' settings.
        The default using 'explicit' for 'string' format and 'implicit'
        for 'latex' format.
        '''
        default_style = ("explicit" if formatType=='string' else 'implicit')
        if (self.getStyle("parameterization", default_style) == "explicit"):
            return True
        return False
    
    def _formatted_checkpoints(self, formatType, *, 
                               use_explicit_parameterization=None,
                               ellipses=None, operator=None,
                               **kwargs):
        if use_explicit_parameterization is None:
            use_explicit_parameterization = (
                    self._use_explicit_parameterization(formatType))
        check_points = [self.first(), self.last()]
        if use_explicit_parameterization and not self.is_parameter_independent:
            check_points.insert(1, self.body)
        formatted_sub_expressions = \
            [subExpr.formatted(formatType, operator=operator,
                               **kwargs) 
             for subExpr in check_points]
        if self.is_parameter_independent:
            from proveit.number import one
            repeats_str = (r'\textrm{ repeats}' if formatType=='latex' 
                           else 'repeats')
            if self.start_index==one:
                formatted_sub_expressions.insert(
                        1, '%s %s'%(self.end_index.formatted(formatType),
                                    repeats_str))
            else:
                to_str = (r'\textrm{ to }' if formatType=='latex' else 'to')
                from_str = (r'\textrm{from }' if formatType=='latex' 
                            else 'from')          
                formatted_sub_expressions.insert(
                        1, ('%s %s %s %s'
                            %(from_str,
                              self.start_index.formatted(formatType), to_str,
                              self.end_index.formatted(formatType))))
        if ellipses is None:
            if use_explicit_parameterization or self.is_parameter_independent:
                # Use the format:
                # x_1, ..x_k.., x_n
                # Or for nested ExprRanges:
                # x_{1,1}, ..x_{1,k}.., x_{1,n}, 
                # ....x_{j,1}, ..x_{j,k}.., x_{j,n}....,
                # x_{m,1}, ..x_{m,k}.., x_{m,n}
                ellipsis = '..'
            else:
                ellipsis = ('\ldots' if formatType=='latex' 
                            else '...')
            # When ranges are nested, double-up (or triple-up, etc)
            # the ellipsis to make the nested structure clear.
            ellipses = ellipsis*self.nested_range_depth()
        if use_explicit_parameterization or self.is_parameter_independent:
            # e.g., ..x_k..
            formatted_sub_expressions[1] = \
                ellipses+formatted_sub_expressions[1]+ellipses
        else:
            # Insert the ellipses between the two "checkpoints".
            # e.g., x_1, ..., x_n
            formatted_sub_expressions.insert(1, ellipses)
        return formatted_sub_expressions
        
    def formatted(self, formatType, fence=False, subFence=True, 
                  operator=None, **kwargs):
        if operator is None:
             # comma is the default formatted operator
            formatted_operator = ', '
        elif isinstance(operator, str):
            formatted_operator = operator
        else:
            formatted_operator = operator.formatted(formatType)
        formatted_sub_expressions = self._formatted_checkpoints(
                formatType, fence=subFence, with_ellipses=True,
                operator=operator)
        # Normally the range will be wrapped in an ExprTuple and 
        # fencing will be handled externally.  When it isn't, we don't 
        # want to fence it  anyway.
        return formatted_operator.join(formatted_sub_expressions)
    
    def getInstance(self, index, assumptions=USE_DEFAULTS, 
                    requirements=None, equality_repl_requirements=None):
        '''
        Return the range instance with the given Lambda map
        index as an Expression, using the given assumptions as 
        needed to interpret the index expression.  Required
        truths, proven under the given assumptions, that 
        were used to make this interpretation will be
        appended to the given 'requirements' (if provided).
        '''
        from proveit.number import LessEq
        
        if requirements is None:
            # requirements won't be passed back in this case 
            requirements = [] 
        
        # first make sure that the indices are in the range
        start_index, end_index = self.start_index, self.end_index
        for first, second in ((start_index, index), (index, end_index)):
            relation = None
            try:
                relation = LessEq.sort([first, second], reorder=False, 
                                       assumptions=assumptions)
            except:
                raise RangeInstanceError(
                        "Indices not provably within the range "
                        "range: %s <= %s"%(first, second)) 
            requirements.append(relation)
        
        # map to the desired instance
        return self.lambda_map.apply(
                index, assumptions=assumptions, requirements=requirements,
                equality_repl_requirements=equality_repl_requirements)

    def _possibly_free_var_ranges(self, exclusions=None):
        '''
        Return the dictionary mapping Variables to forms w.r.t. ranges
        of indices (or solo) in which the variable occurs as free or 
        not explicitly and completely masked.  Examples of "forms":
            x
            x_i
            x_1, ..., x_n
            x_{i, 1}, ..., x_{i, n_i}
            x_{1, 1}, ..., x_{1, n_1}, ......, x_{m, 1}, ..., x_{m, n_m}
        
        If this Expression is in the exclusion set, or contributes 
        directly to a form that is in the exclusions set, skip over it.
        For example, given the expression
            a*x_{i, 1} + ... + a*x_{i, n_1}
        if x_{i, 1}, ..., x_{i, n_i} is in the exclusion set,
        then 'a' will be the only free variable reported.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            getParamVar        
        if exclusions is not None:
            if self in exclusions:
                return dict() # this is excluded
            # For the body, extend the exclusion set as necessary to
            # exclude anything contributing directly to a form that is
            # in the exclusion set.  For example, if 
            # x_1, ..., x_n is in the exclusion set and 
            # self.parameter==k and self.start_index==1 and 
            # self.end_index==n then add x_k to the exclusion set of 
            # this body.
            body_exclusions = set(exclusions)
            for exclusion in exclusions:
                if (isinstance(exclusion, ExprRange) and
                        exclusion.start_index == self.start_index and
                        exclusion.end_index == self.end_index):
                    new_exclusion = exclusion.body.replaced(
                            {exclusion.parameter:self.parameter})
                    body_exclusions.add(new_exclusion)
        else:
            body_exclusions = None
        body_forms_dict = \
            self.body._possibly_free_var_ranges(exclusions=body_exclusions)
        # deep copy body_forms_dict into forms_dict
        forms_dict = {var:set(ranges) for var, ranges 
                      in body_forms_dict.items()}
        param = self.parameter
        # Eliminate the parameter; it is not a free variable.
        if param in forms_dict.keys():
            forms_dict[param].discard(param)
            if len(forms_dict[param])==0:
                forms_dict.pop(param)        
        for expr in self._subExpressions[1:]:
            # Skip the first sub-expression. We've already treated that.
            for var, forms in \
                    expr._possibly_free_var_ranges(exclusions=exclusions).items():
                forms_dict.setdefault(var, set()).update(forms)        
        # The var ranges of the body that depend upon self.parameter
        # will be promoted to expression ranges over the range of this 
        # ExprRange.  For example, if x_k is one of the var ranges of
        # the body and self.parameter==k, then x_k will be replaced
        # by x_1, ..., x_n.
        for parameterized_var_range in self._parameterized_var_ranges(
                body_forms_dict):
            var = getParamVar(parameterized_var_range)
            assert var in forms_dict
            forms_dict[var].remove(parameterized_var_range)
            forms_dict[var].add(ExprRange(param, parameterized_var_range,
                                         self.start_index, self.end_index))
        return forms_dict
        
    def _parameterized_var_ranges(self, body_forms_dict=None):
        '''
        Yield each of body._possibly_free_var_ranges() that involves the
        ExprRange parameter as a free variable.
        For example, for ((x_1 < x_{1+1}) and ... and (x_n < x_{n+1})),
        the following will be yielded if k is the ExprRange parameter:
            x_k, x_{k+1}.
        Another example:
            a*x_{1, 1} + ... + a*x_{1, n_1} + ...... 
                + a*x_{m, 1} + ... + a*x_{m, n_1}
        will give
            x_{i, 1}, ..., x_{i, n_i}
        if i is the ExprRange parameter.
        '''
        if body_forms_dict is None:
            body_forms_dict = self.body._possibly_free_var_ranges()
        param = self.parameter
        for var, forms in body_forms_dict.items():
            for form in forms:
                if form==self: continue
                if form==self.parameter: 
                    continue # don't count the parameter itself.
                var_forms_of_form = form._possibly_free_var_ranges()
                if (param in var_forms_of_form
                        and param in var_forms_of_form[param]):
                    yield form
    
    def _possibly_reduced_range_entries(self, expr_range, assumptions, 
                                        requirements):
        '''
        Yield the entries corresponding to the given expr_range after
        the possible reduction.  If there is no reduction, the
        'expr_range' itself is yielded.
        Note: this cannot be done via the regular 'auto_reduction' 
        method because the reductions are of the form of reducing 'self' 
        wrapped in an ExprTuple rather than 'self' itself.
        '''
        from proveit import Judgment
        from proveit._common_ import f, i, j, m, n
        from proveit.logic import Equals
        from proveit.number import Add, one
        if (not defaults.auto_reduce 
                or ExprRange in defaults.disabled_auto_reduction_types):
            # Auto-reduction for this is disabled.
            yield expr_range
            return
        lambda_map = expr_range.lambda_map
        start_index = expr_range.start_index
        end_index = expr_range.end_index
        if start_index == end_index:
            # We can do a singular range reduction.
            # Temporarily disable automation to avoid infinite
            # recursion.
            from proveit.core_expr_types.tuples._theorems_ import \
                singular_range_reduction, singular_nested_range_reduction
            defaults.disabled_auto_reduction_types.add(ExprRange)
            try:
                if expr_range.nested_range_depth() > 1:
                    lambda_map = Lambda((expr_range.parameter, expr_range.body.parameter), expr_range.body.body)
                    reduction = singular_nested_range_reduction.instantiate({f: lambda_map, m: start_index,
                                                                             i: expr_range.first().start_index,
                                                                             j: expr_range.first().end_index},
                                                                            assumptions=assumptions)
                else:
                    reduction = singular_range_reduction.instantiate(
                            {f:lambda_map, i:start_index},
                            assumptions=assumptions)
            finally:
                # Re-enable automation.
                defaults.disabled_auto_reduction_types.remove(ExprRange)
        else:
            # If the start and end are literal ints and form an
            # empty range, then it should be straightforward to
            # prove that the range is empty.
            from proveit.number import isLiteralInt
            empty_req = Equals(Add(end_index, one), start_index)
            if isLiteralInt(start_index) and isLiteralInt(end_index):
                if end_index.asInt()+1 == start_index.asInt():
                    empty_req.prove()
            if empty_req.proven(assumptions):
                # We can do an empty range reduction
                # Temporarily disable automation to avoid infinite
                # recursion.
                if expr_range.nested_range_depth() > 1:
                    # this is a nested range, but we know
                    # that the outer range reduces to an empty range,

                    # We can do an empty range reduction on the entire expression
                    # Temporarily disable automation to avoid infinite
                    # recursion.
                    from proveit.core_expr_types.tuples._theorems_ import \
                        empty_outside_range_of_range
                    defaults.disabled_auto_reduction_types.add(ExprRange)
                    try:
                        nest_end_index = expr_range.first().end_index
                        nest_start_index = expr_range.first().start_index
                        lambda_map = Lambda((expr_range.parameter, expr_range.body.parameter), expr_range.body.body)
                        reduction = empty_outside_range_of_range.instantiate(
                            {f: lambda_map, m: start_index, n: end_index, i: nest_start_index, j: nest_end_index},
                            assumptions=assumptions)
                    finally:
                        # Re-enable automation.
                        defaults.disabled_auto_reduction_types.remove(ExprRange)
                else:
                        from proveit.core_expr_types.tuples._axioms_ import \
                            empty_range_def
                        defaults.disabled_auto_reduction_types.add(ExprRange)
                        try:
                            reduction = empty_range_def.instantiate(
                                    {f:lambda_map, i:start_index, j:end_index},
                                    assumptions=assumptions)
                        finally:
                            # Re-enable automation.
                            defaults.disabled_auto_reduction_types.remove(ExprRange)
            elif expr_range.nested_range_depth() > 1:
                # this is a nested range so the inner range could be empty.

                # If the start and end of the inner range are literal ints and form an
                # empty range, then it should be straightforward to
                # prove that the entire range is empty.
                from proveit.number import isLiteralInt
                empty_req = Equals(Add(expr_range.first().end_index, one), expr_range.first().start_index)
                if isLiteralInt(expr_range.first().start_index) and isLiteralInt(expr_range.first().end_index):
                    if expr_range.first().end_index.asInt() + 1 == expr_range.first().start_index.asInt():
                        empty_req.prove()
                if empty_req.proven(assumptions):
                    # We can do an empty range reduction on the entire expression
                    # Temporarily disable automation to avoid infinite
                    # recursion.
                    from proveit.core_expr_types.tuples._theorems_ import \
                        empty_inside_range_of_range
                    defaults.disabled_auto_reduction_types.add(ExprRange)
                    try:
                        nest_end_index = expr_range.first().end_index
                        nest_start_index = expr_range.first().start_index
                        lambda_map = Lambda((expr_range.parameter, expr_range.body.parameter), expr_range.body.body)
                        reduction = empty_inside_range_of_range.instantiate(
                            {f: lambda_map, m: start_index, n: end_index, i: nest_start_index, j: nest_end_index},
                            assumptions=assumptions)
                    finally:
                        # Re-enable automation.
                        defaults.disabled_auto_reduction_types.remove(ExprRange)
                else:
                    yield expr_range  # no reduction
                    return

            else:
                yield expr_range # no reduction
                return
        assert isinstance(reduction, Judgment)
        assert isinstance(reduction.expr, Equals)
        assert len(reduction.expr.operands) == 2
        assert reduction.expr.operands[0] == ExprTuple(expr_range)
        reduced_tuple = reduction.expr.operands[1]
        assert isinstance(reduced_tuple, ExprTuple)
        requirements.append(reduction)
        for entry in reduced_tuple:
            yield entry
    
    def _replaced_entries(self, repl_map, allow_relabeling,
                          assumptions, requirements,
                          equality_repl_requirements):
        '''
        Returns this expression with sub-expressions replaced 
        according to the replacement map (repl_map) dictionary.
        
        'assumptions' and 'requirements' are used when an operator is
        replaced by a Lambda map that has a range of parameters such 
        that the length of the parameters and operands must be proven 
        to be equal.  See the Operation.replaced and Lambda.apply 
        documentation for more details.
        
        Expansion replacements of a range of indexed variables must
        be made explicit for the corresponding range (and therefore
        unambiguous and direct).  For example, to expand x in the
        following expression
            (x_1 < x_{1+1}) and ... and (x_n < x_{n+1})
        there must be a replacement in repl_map for
        (x_1, ..., x_n) as well as (x_{1+1}, ..., x_{n}).
        In an instantiation, this can be done by supplying
        instantiations of multiple forms of ranges of x.  For example:
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{1+1}, ..., d_{n+1})
        where the following requirements must be satisfied:
            (1, ..., n, n+1) = (1, ..., n+1)
            (1, 1+1, ..., n+1) = (1, ..., n+1)
            (a_1, ..., a_n, b) = (c, d_{1+1}, ..., d_{n+1})
        
        When multiple indexed variables are expanded within the 
        ExprRange, the expansions must be in exact correspondence
        with respect to range start and index indices of the expansion.
        The above example meets this requirement since
            a_1, ..., a_n
            matches with
            b_{1+1}, ..., b_{n+1}
            by both being ranges from 1 to n.
        This expansion would fail this requirement
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{2}, ..., d_{n+1})
        since d_{2}, ..., d_{n+1} is a range from 2 to n+1.
        
        Here is another valid instantiation:
            (x_1, ..., x_n, x_{n+1}) : 
                (a_1, ..., a_n, a_{n+1}, b_1, ..., b_n, b_{n+1})
            (x_1, x_{1+1}, ..., x_{n+1}) : 
                (a_1, a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1})
        since
             a_1, ..., a_n, a_{n+1}, b_1, ..., b_n
             matches with
             a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1}
             with the pattern: 1 to n, single element, 1 to n.
        
        See the Lambda.apply documentation for a related discussion.
        '''
        from proveit._core_.expression.expr import attempt_to_simplify
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            getParamVar, extract_param_replacements
        from proveit._core_.expression.label.var import safeDummyVar
        from proveit.logic import Equals#, InSet
        from proveit.number import Add, one#, Interval
                        
        if len(repl_map)>0 and (self in repl_map):
            # The full expression is to be replaced.
            return repl_map[self]

        if requirements is None: requirements = []
        assumptions = defaults.checkedAssumptions(assumptions)
        # We will turn on the `indices_must_match` flag when the
        # replacement index ranges must match the original range of
        # indices and not just match in length:
        indices_must_match = False
        # Stash anything we temporarily pop out of the repl_map.
        repl_map_stash = dict()
        
        # `var_range_forms` maps variables to the set of equivalent 
        # forms of indexing over a range pertinent to getting the 
        # replaced entries of this ExprRange.  
        # Remove them from the `repl_map` temporarily.
        var_range_forms = dict()
        expanding_occurrences = set()
        parameterized_var_ranges = list(self._parameterized_var_ranges())
        for occurrence in parameterized_var_ranges:
            # `occurrence` may be something like x_k or
            # x_{k,1}, ..., x_{k,n}
            # where `k` is `self.parameter`.
            # If repl_map maps `x` to a set, in this example, 
            # then it has an expansion for any of the forms that
            # are contained in the set.
            var = getParamVar(occurrence)
            if var in var_range_forms: 
                expanding_occurrences.add(occurrence)
                # Already added this `var` to `var_expansion_forms` and 
                # removed it from `repl_map`:
                continue
            repl = repl_map.get(var, None)
            if isinstance(repl, set):
                expanding_occurrences.add(occurrence)
                var_range_forms[var] = repl
                repl_map_stash[var] = repl_map.pop(var)
            elif not indices_must_match:
                # If some variables are expanded but others are not,
                # our replacement index ranges will need to match the 
                # original range of indices to be a valid replacement.
                indices_must_match = True
                reason_indices_must_match = var # temporary assignment
        if len(var_range_forms) > 0:
            expanding_var = next(iter(var_range_forms))
            if indices_must_match:
                # `reason_indices_must_match` was temporarily assigned
                # to a Variable that is not being expanded.  Change it
                # to a proper message now that we have a variable that
                # is being expanded.
                reason_indices_must_match = (
                        "not all of the indexed variables being indexed "
                        "by the ExprRange parameter are being expanded "
                        "(%s is expanded but %s is not)"
                        %(expanding_var, reason_indices_must_match))
        
        # Make all of the replacements except for the variables
        # being expanded.  If variables are to be expanded, this
        # result will be used for getting the start and end indices
        # ('starts' and 'ends').
        subbed_expr_range = self.replaced(
                repl_map, allow_relabeling, assumptions, requirements,
                equality_repl_requirements)
        if len(var_range_forms) == 0:
            # Nothing to expand.
            # However, we may perform a reduction of the range
            # if it is known to be empty or singular.
            for entry in self._possibly_reduced_range_entries(
                    subbed_expr_range, assumptions, requirements):
                yield entry
            return # Done.
        
        # Need to handle the change in scope within the lambda 
        # expression.
        # Note, we should have already gotten requirements
        # when calling self.replaced.
        dummy_reqs = []
        dummy_equality_repl_reqs = set()
        new_params, inner_repl_map, inner_assumptions \
            = self.lambda_map._inner_scope_sub(
                    repl_map, allow_relabeling, assumptions,
                    dummy_reqs, dummy_equality_repl_reqs)
        # Sanity check that we didn't introduce new requirements.
        # "_inner_scope_sub" should not introduce anything that
        # wasn't introduced when we called `self.replaced`.
        prev_reqs = set(requirements)
        for req in dummy_reqs: assert req in prev_reqs
        
        assert len(new_params)==1
        new_param = new_params[0]
        safe_dummy_var = safeDummyVar(self.body, self.parameter)
        # Restore the repl_map, adding back in what was temporarily
        # popped out.
        repl_map.update(repl_map_stash)
        
        # If the range parameter is used for anything other than an
        # index of an indexed variable, or not all of the 
        # parameterized_var_ranges are expanded, all of the new indices
        # must match the original indices, not just the length.
        excluded_var_ranges = \
            self.body._possibly_free_var_ranges(
                    exclusions=parameterized_var_ranges)
        if self.parameter in excluded_var_ranges:
            indices_must_match = True
            reason_indices_must_match = (
                    "the ExprRange parameter appears outside of IndexedVar "
                    "indices")
        
        # Create `expansions_dict` to map each of the variables being
        # expanded to the expansion that is relevent for this ExprRange.
        expansions_dict = dict()
        #orig_parameters = extract_parameters(self)
        #starts = extract_start_indices(subbed_expr_range)
        #ends = extract_end_indices(subbed_expr_range)
        orig_parameter = self.parameter
        subbed_start_index = subbed_expr_range.start_index
        subbed_end_index = subbed_expr_range.end_index
        #assert len(starts)==len(ends)==len(orig_parameters)
        for occurrence in expanding_occurrences:
            # We need to create a proper "variable range" with simple
            # parameterized indices.  Any shifts of the indices of
            # the indexed_var_or_range must be absorbed into the
            # starting/ending indices.  For example
            # x_{k+1} with k going from 1 to n should change to
            # x_k with k going from 1+1 to n+1.
            indexed_var = innermost_body(occurrence)
            var_indices = indexed_var.indices
            var = indexed_var.var
            
            param_index = None
            
            # Note: We'll make replacements of IndexedVar indices and start
            # and end range indices of the occurrence, but not the variable
            # itself, before we look up the replacement for the corresponding
            # variable range.
            occurrence_map = dict(repl_map)
            occurrence_map.pop(var)
            for idx in var_indices:
                if orig_parameter in free_vars(idx, err_inclusively=True):
                    if param_index is not None:
                        raise ImproperReplacement(
                                self, repl_map,
                                "Failure to expand %s because %s is not a valid "
                                "occurrence with the range parameter %s; multiple "
                                "index occurrences are not allowed."
                                %(self, occurrence, orig_parameter))
                    start_with_absorbed_shift = \
                        idx.replaced({orig_parameter:subbed_start_index})
                    end_with_absorbed_shift = \
                        idx.replaced({orig_parameter:subbed_end_index})
                    param_index = idx
                    occurrence_map[idx] = orig_parameter
                    if idx != orig_parameter:
                        # We'll map the original parameter to a safe dummy var
                        # so we can detect if there are other instances of
                        # the original parameter with a different shift.
                        occurrence_map[orig_parameter] = safe_dummy_var
            if param_index is None:
                raise ImproperReplacement(
                        self, repl_map,
                        "Failure to expand %s because %s is not a valid "
                        "occurrence with the range parameter %s; not used as "
                        "an index."
                        %(self, occurrence, orig_parameter))
            orig_occurrence = occurrence
            occurrence = occurrence.replaced(
                    occurrence_map, allow_relabeling, assumptions, requirements,
                    equality_repl_requirements)
            if safe_dummy_var in free_vars(occurrence, err_inclusively=True):
                # There was an instance of the original parameter with a
                # different shift than what we used.  That's not allowed.
                raise ImproperReplacement(
                        self, repl_map,
                        "Failure to expand %s because %s does not use a "
                        "consistent shift the range parameter %s."
                        %(self, orig_occurrence, orig_parameter))
                
            var_range = ExprRange(orig_parameter, occurrence, 
                                  start_with_absorbed_shift,
                                  end_with_absorbed_shift)
                        
            # Now wrap this "variable range" in an ExprTuple and see
            # if it has a known expansion.
            var_tuple = ExprTuple(var_range)
            var = getParamVar(occurrence)
            if var_tuple not in inner_repl_map:
                key_var = lambda key : (getParamVar(key[0]) if 
                                        isinstance(key, ExprTuple) 
                                        else getParamVar(key))
                var_replacements = \
                    {key:value for key, value in inner_repl_map.items() if 
                     key_var(key)==var}
                print('problem self', self, repl_map)
                raise ImproperReplacement(
                        self, repl_map,
                        "Failure to expand %s because there is no explicit "
                        "expansion for %s.  The known expansions for "
                        "this variable are %s.  "
                        "(Note that multiple, equivalent expansion forms "
                        "may be provided to fulfill this requirement)."
                        %(self, var_tuple, var_replacements))
            repl = inner_repl_map.pop(var_tuple)
            if not isinstance(repl, ExprTuple):
                raise ImproperReplacement(
                        self, repl_map,
                        "Invalid replacement %s for %s; it must be an "
                        "ExprTuple."%(var_tuple, repl))
            expansions_dict[occurrence] = repl.entries

        def raise_failed_expansion_match(first_expansion, expansion,
                                         first_indexed_var_or_range,
                                         indexed_var_or_range):
            raise ImproperReplacement(
                    self, repl_map,
                    "When expanding IndexedVar's within an ExprRange whose "
                    "parameter is the index, their expansion ExprRange "
                    "indices must all match. %s vs %s do not match as "
                    "respected expansions for %s and %s."
                    %(first_expansion, expansion,
                      first_indexed_var_or_range, indexed_var_or_range))
                
        # Do we need to match the new indices to the original indices?
        if indices_must_match:
            # Yes.  Prepare to do that.
            new_indices = []
            next_index = subbed_start_index
        
        # Divy up the expansions into aligned entries, each with
        # its own replacement map.  This is in preparation to yield
        # a replaced version of the body for each of these entries.
        # Each entry is either singular (at this level) or an ExprRange
        # (where we will yield a new ExprRange covering a portion of
        # the original ExprRange).  The "alignment" of the entries
        # means that corresponding ExprRange entries must have the
        # same start and end indices (i.e., for different expansions).
        body = self.body
        entry_repl_maps = None
        # This will be a list with only the ExprRange entries and None
        # for non-ExprRange entries.
        first_expansion_entry_ranges = None
        for indexed_var_or_range, expansion in expansions_dict.items():
            parameters = [indexed_var_or_range]
            parameter_vars = [getParamVar(indexed_var_or_range)]
            expansion_iter = iter(expansion)
            # Replacement maps corresponding with this
            # 'indexed_var_or_range' and 'expansion'.
            expansion_repl_maps = []
            expansion_entry_ranges = []
            while True:
                entry_repl_map = dict()
                # Peek ahead; get the next entry without advancing the
                # iter.
                head, expansion_iter = more_itertools.spy(expansion_iter)
                if len(head)==0: break # No more entries.
                # See if the next entry is to be a proper ExprRange 
                # entry at this level.
                entry = head[0]
                if (isinstance(entry, ExprRange) and 
                        is_at_same_nested_range_level(indexed_var_or_range, 
                                                      entry.body)):
                    # This is a proper ExprRange entry (at this level).
                    # The replacement map will map 
                    # 'indexed_var_or_range' to the body of the entry
                    # with the parameter changed to our 'new_param'.
                    param_repl_map = {entry.parameter:new_param}
                    new_body = entry.body.replaced(param_repl_map)
                    entry_repl_map[indexed_var_or_range.replaced(param_repl_map)] \
                        = new_body
                    expansion_entry_ranges.append(entry)
                    # Advance the "expansion iter".
                    next(expansion_iter)
                else:
                    # This is not a proper ExprRange entry.  It may
                    # be a simple singular entry, or multiple entries
                    # for a nested ExprRange (which is why we need
                    # to use the 'extract_param_replacements' method).
                    extract_param_replacements(
                            parameters, parameter_vars, body, 
                            expansion_iter, assumptions, requirements, 
                            entry_repl_map)
                    # Mark as a non-ExprRange entry by simply appending
                    # None.
                    expansion_entry_ranges.append(None)
                expansion_repl_maps.append(entry_repl_map)
            if first_expansion_entry_ranges is None:
                # This is the first expansion we are processing.
                entry_repl_maps = expansion_repl_maps
                first_expansion_entry_ranges = expansion_entry_ranges
                first_expansion = expansion
                first_indexed_var_or_range = indexed_var_or_range
            else:
                # We have processed other expansions.  Make sure
                # they are consistent w.r.t. ExprRange entries
                # and total number of entries.
                if len(first_expansion_entry_ranges) != len(expansion_entry_ranges):
                    # Failing to have the same number of entries.
                    raise_failed_expansion_match(
                            first_expansion, expansion,
                            first_indexed_var_or_range, 
                            indexed_var_or_range)
                for first_expansion_entry, expansion_entry in zip(
                        first_expansion_entry_ranges, expansion_entry_ranges):
                    if (isinstance(expansion_entry, ExprRange) 
                            != isinstance(first_expansion_entry, ExprRange)):
                        # Failing to match w.r.t. being an ExprRange
                        # entry or not.
                        raise_failed_expansion_match(
                                first_expansion, expansion, 
                                first_indexed_var_or_range, 
                                indexed_var_or_range)
                    if isinstance(expansion_entry, ExprRange):
                        if (expansion_entry.start_index 
                                !=  first_expansion_entry.start_index):
                            # Failed to have the same ExprRange range 
                            # (different start).
                            raise_failed_expansion_match(
                                    first_expansion, expansion, 
                                    first_indexed_var_or_range, 
                                    indexed_var_or_range)
                        if (expansion_entry.end_index !=  
                                first_expansion_entry.end_index):
                            # Failed to have the same ExprRange range 
                            # (different end).
                            raise_failed_expansion_match(
                                    first_expansion, expansion, 
                                    first_indexed_var_or_range, 
                                    indexed_var_or_range)
                # Combine the 'expansion_repl_maps' into the
                # 'entry_repl_maps' for all expansions.
                for entry_repl_map, expansion_repl_map in zip(
                        entry_repl_maps, expansion_repl_maps):
                    entry_repl_map.update(expansion_repl_map)
                
        def update_map(orig_repl_map, update):
            '''
            Given an original replacement map, use the 'update' dictionary
            to make replacements in all of its keys and values and then
            add the update entrie(s).
            '''
            new_repl_map = dict()
            for key, val in orig_repl_map.items():
                key = key.replaced(update)
                if isinstance(val, set):
                    val = {elem.replaced(update) for elem in val}
                else:
                    val = val.replaced(update)
                new_repl_map[key] = val
            new_repl_map.update(update)
            return new_repl_map
        
        # Yield a replacement for each of the aligned entry of the
        # expansions.  May be a singular entry or an ExprRange entry
        # representing a portion of the original range.
        for first_expansion_entry_range_or_none, entry_repl_map in zip(
                first_expansion_entry_ranges, entry_repl_maps):
            # Use the 'inner replacement map' updated with the
            # 'entry replacement map' to get the 'full entry replacment
            # map'.
            full_entry_repl_map = dict(inner_repl_map)
            full_entry_repl_map.update(entry_repl_map)
            # Now yield the substitution corresponding to this entry.
            if first_expansion_entry_range_or_none is not None:
                assert isinstance(first_expansion_entry_range_or_none,
                                  ExprRange)
                # For an ExprRange entry, yield a new ExprRange 
                # representing a portion of th eoriginal range.
                first_expansion_entry = first_expansion_entry_range_or_none
                start_index = first_expansion_entry.start_index
                end_index = first_expansion_entry.end_index
                
                # Let's keep this simple and not worry about this
                # "range assumptions".
                # If needed, we can use explicit axioms/theorems to
                # make use of this property rather than in the core.
                # If we change our minds, the range assumption should
                # also be employed in the ExprRange._replaced method.
                #range_assumption = InSet(new_param, 
                #                         Interval(start_index, end_index))
                
                entry_assumptions = inner_assumptions # + [range_assumption]
                param_repl_map= {orig_parameter:new_param}
                full_entry_repl_map = update_map(full_entry_repl_map, param_repl_map)
                entry = ExprRange(new_param,
                                  body.replaced(full_entry_repl_map, 
                                                allow_relabeling,
                                                entry_assumptions,
                                                requirements,
                                                equality_repl_requirements),
                                  start_index, end_index)
                # We may perform a reduction of the range if it is known
                # to be empty or singular.
                for entry in self._possibly_reduced_range_entries(
                        entry, assumptions, requirements):
                    yield entry
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(ExprRange(new_param, new_param, 
                                            start_index, end_index))
                    next_index = Add(end_index, one)
            else:
                # For a singular element entry, yield the replaced
                # element.
                if indices_must_match:
                    # Attempt to simplify the 'next_index' only when 
                    # we need it.
                    next_index = attempt_to_simplify(
                            next_index, assumptions, requirements)
                    # The actual range parameter index is needed:
                    param_repl_map= {orig_parameter:next_index}
                    full_entry_repl_map = update_map(full_entry_repl_map, param_repl_map)
                    #full_entry_repl_map[orig_parameter] = next_index

                if isinstance(body, ExprRange):
                    # A nested ExprRange may need to be expanded.
                    for subentry in body._replaced_entries(
                            full_entry_repl_map, allow_relabeling,
                            inner_assumptions, requirements,
                            equality_repl_requirements):
                        yield subentry
                else:
                    yield body.replaced(full_entry_repl_map, allow_relabeling,
                                        inner_assumptions, requirements,
                                        equality_repl_requirements)
                    
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(next_index)
                    next_index = Add(next_index, one)
                
        if indices_must_match:
            # The range parameter appears outside of
            # IndexedVars.  That means that we must match new
            # and original indices precisely, not just their length.
            requirement = Equals(ExprTuple(*new_indices), 
                                 ExprTuple(ExprRange(new_param, new_param,
                                                     subbed_start_index, 
                                                     subbed_end_index)))
            if requirement.lhs==requirement.rhs:
                # No need for the requirement if it is a trivial
                # reflexive identity.
                return
            try:
                requirements.append(requirement.prove(assumptions))
            except ProofFailure as e:
                raise ImproperReplacement(
                        self, repl_map,
                        "ExprRange indices failed to match expansion "
                        "which is necessary because %s: %s."
                        %(reason_indices_must_match, e))
    
    def parameters(self):
        '''
        Return a list of parameters, one for each nested
        ExprRange.   
        '''
        return extract_parameters(self)
        
    def innermost_body(self):
        '''
        Return the innermost body of a nested ExprRange.
        '''
        return innermost_body(self)

    def start_indices(self):
        '''
        Return a list of starting indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has start indices (m, i_m).  
        '''
        return extract_start_indices(self)    

    def end_indices(self):
        '''
        Return a list of ending indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has end indices (n, j_n).      
        '''
        return extract_end_indices(self)    
    
    def mapped_range(self, body_map_fn):
        '''
        Generate an ExprRange with the same external structure
        as this range but converts the innermost by applying the
        'body_map_fn' to it.
        '''
        inner_body = self.innermost_body(self)
        new_inner_body = body_map_fn(inner_body)
        parameters = extract_parameters(self)
        start_indices = extract_start_indices(self)
        end_indices = extract_end_indices(self)
        return nestedRange(parameters, new_inner_body, start_indices,
                           end_indices)
        
    def partition(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a split version in the following manner: 
            (f(self.start_index), ..., f(self.end_index)) =
            (f(self.start_index), ..., f(before_split_index), 
             f(before_split_index+1), ..., f(self.end_index))
        where f represents the self.lambda_map.
        '''
        from proveit._common_ import f, i, j, k
        from proveit.logic import Equals
        from proveit.number import Add, one, subtract
        from proveit.core_expr_types.tuples._axioms_ import (
                range_extension_def)
        from proveit.core_expr_types.tuples._theorems_ import (
                partition_front, partition_back, partition)
        
        lambda_map = self.lambda_map
        start_index, end_index = self.start_index, self.end_index
        if end_index == Add(before_split_idx, one):
            # special case which uses the axiom:
            return range_extension_def.instantiate(
                    {f:lambda_map, i:start_index, j:before_split_idx},
                    assumptions=assumptions)
        elif before_split_idx == self.start_index:
            # special case when peeling off the front
            return partition_front.instantiate(
                    {f:lambda_map, i:self.start_index, j:self.end_index},
                     assumptions=assumptions)
        elif (before_split_idx == subtract(end_index, one) or
              Equals(before_split_idx, subtract(end_index, one)).proven(assumptions)):
            # special case when peeling off the back
            return partition_back.instantiate(
                    {f:lambda_map, i:start_index, j:end_index},
                     assumptions=assumptions)
        else:
            return partition.instantiate(
                    {f:lambda_map, i:start_index, j:before_split_idx,
                     k:end_index}, assumptions=assumptions)
    
    def shift_equivalence(self, *, old_shift=None, new_start=None, 
                          new_end=None, new_shift=None, 
                          assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a shifted version in the following manner: 
            (f(self.start_index+old_shift), ..., f(self.end_index+old_shift)) =
            (f(new_start+new_shift), ..., f(new_start+new_shift))
        where f is adapted from self.lambda_map according to 'old_shift'.
        If any of the 'new' parameters are unspecified, we attempt 
        to deduce them from the other parameters.
        '''
        from proveit._common_ import a, b, f, i, j, k, l
        from proveit.number import Add, Neg, subtract
        from proveit._core_.expression.label.var import safeDummyVar
        from proveit.core_expr_types.tuples._theorems_ import (
                shift_equivalence, shift_equivalence_both)
        
        if old_shift is None:
            _f = self.lambda_map
        else:
            old_shifted_param = Add(self.parameter, old_shift)
            safe_var = safeDummyVar(self.body)
            shifted_body = self.body.replaced({old_shifted_param:safe_var})
            if self.parameter in free_vars(shifted_body, err_inclusively=True):
                raise ValueError("The given 'old_shift' of %s does apply "
                                 "to %s"%(old_shift, self.lambda_map))
            _f = Lambda(self.parameter, 
                        shifted_body.replaced({safe_var:self.parameter}))
        
        _i, _j = self.start_index, self.end_index
        
        if new_shift is not None:
            net_shift = new_shift
            if old_shift is not None:
                net_shift = subtract(new_shift, old_shift).simplified(
                        assumptions=assumptions)
            if new_start is None:
                # new start = _i - new_shift
                new_start = subtract(_i, net_shift).simplified(
                        assumptions=assumptions)
            if new_end is None:
                # new_end = _j - new_shift
                new_end = subtract(_j, net_shift).simplified(
                        assumptions=assumptions)
        elif new_start is None:
            # new_start = new_end + i - j
            new_end = Add(new_start, _i, Neg(_j)).simplified(
                                  assumptions=assumptions)
        elif new_end is None:
            # new_end = new_start + j - i
            new_end = Add(new_start, _j, Neg(_i)).simplified(
                                  assumptions=assumptions)
        
        _k, _l = new_start, new_end
        
        if new_shift is None:
            # Compute the new shift based upon the other parameters.
            if old_shift is None:
                new_shift = subtract(_i, _k).simplified(assumptions=assumptions)
            else:
                new_shift = Add(_i, old_shift, Neg(_k)).simplified(
                        assumptions=assumptions)
        
        if old_shift is None:
            return shift_equivalence.instantiate(
                    {f:_f, a:new_shift, i:_i, j:_j, k:_k, l:_l}, 
                    assumptions=assumptions)
        else:
            return shift_equivalence_both.instantiate(
                    {f:_f, a:old_shift, b:new_shift, i:_i, j:_j, k:_k, l:_l},
                     assumptions=assumptions)    
    
    """
    def _var_index_shifts_in_ranges(self, var, shifts):
        '''
        Given a 'var' (e.g., 'x'), pass back, via the set 'shifts', 
        all of the constant indexed shifts to the ExprRange parameter
        within ExprRanges (e.g., 'x_{1+1}, ..., x_{n+1}' would have
        presumably have a shift of 1).
        '''
        self.body._indexed_var_shifts(var, self.parameter, shifts)
        Expression._var_index_shifts_in_ranges(self, var, shifts)
    """
    
    """
    TODO: change register_equivalence_method to allow and fascilitate these
    method stubs for purposes of generating useful documentation.

    def partitioned(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the right-hand-side of a 'partition'.
        '''
        raise Exception("Should be implemented via InnerExpr.register_equivalence_method")
    
    def split(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        As an InnerExpr method when the inner expression is an ExprRange,
        return the expression with the inner expression replaced by its
        'partitioned' version.
        '''
        raise Exception("Implemented via InnerExpr.register_equivalence_method "
                        "only to be applied to an InnerExpr object.")
    """

def _has_expansion(var_form, repl_map):
    '''
    Return True if and only if the given IndexedVar has
    an expansion in the given replacement map.
    '''
    from proveit._core_.expression.lambda_expr.lambda_expr import \
        getParamVar
    var_repl = repl_map.get(getParamVar(var_form), None)
    # When being expanded, a set of equivalent tuples of 
    # indexed variables is used as the direct variable 
    # replacement (e.g. x : {(x_1, ..., x_{n+1}), 
    #                        (x_1, ..., x_n, x_{n+1})}).
    return isinstance(var_repl, set)   

def extract_start_indices(expr_range):
    '''
    Return a list of starting indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has start indices (m, i_m).      
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        start_index = expr.start_index
        subbed_index = start_index.replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices

def extract_end_indices(expr_range):
    '''
    Return a list of ending indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has end indices (n, j_n).      
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        end_index = expr.end_index
        subbed_index = end_index.replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices

def extract_parameters(expr_range):
    '''
    Return a list of parameters, one for each nested
    ExprRange.
    '''
    parameters = []
    expr = expr_range
    while isinstance(expr, ExprRange):
        parameters.append(expr.parameter)
        expr = expr.body
    return parameters

def innermost_body(expr_range):
    '''
    Return the innermost body of a nested ExprRange.
    '''
    expr = expr_range
    while isinstance(expr, ExprRange):
        expr = expr.body
    return expr

def is_at_same_nested_range_level(expr1, expr2):
    '''
    Return True iff 'expr1' and 'expr2' are either both
    ExprRanges, or nested ExprRanges at the same number of levels.
    '''
    while True:
        if isinstance(expr1, ExprRange) != isinstance(expr2, ExprRange):
            # Levels don't match.
            return False
        if not isinstance(expr1, ExprRange):
            # Made it to the end without encountering a mismatch.
            return True
        # Go another level deeper.
        expr1 = expr1.body
        expr2 = expr2.body

def nestedRange(parameters, body, start_indices, end_indices):
    if len(parameters) > 1:
        # multiple levels
        return ExprRange(parameters[0], 
                         nestedRange(parameters[1:], body,
                                     start_indices[1:], end_indices[1:]),
                         start_indices[0], end_indices[0])
    else:
        # single level
        param = parameters[0]
        start_index, end_index = (start_indices[0],
                                  end_indices[0])
        return ExprRange(param, body, start_index, end_index)

    
def varRange(var, start_index_or_indices, end_index_or_indices):
    from proveit import (safeDummyVars, compositeExpression,
                         IndexedVar)
    start_indices = compositeExpression(start_index_or_indices)
    end_indices = compositeExpression(end_index_or_indices)
    parameters = safeDummyVars(len(start_indices), var, start_indices, 
                               end_indices)
    return nestedRange(parameters, IndexedVar(var, parameters),
                       start_indices, end_indices)

class RangeInstanceError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
