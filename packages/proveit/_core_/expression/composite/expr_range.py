import more_itertools

from proveit._core_.expression.expr import (Expression, MakeNotImplemented,
                                            ImproperReplacement,
                                            free_vars)
from proveit._core_.expression.label.var import safe_dummy_var
from proveit._core_.expression.style_options import StyleOptions, StyleError
from proveit._core_.expression.lambda_expr.lambda_expr import Lambda
from proveit._core_.expression.composite import (
        singular_expression, single_or_composite_expression, ExprTuple)
from proveit._core_.expression.conditional import Conditional
from proveit._core_.proof import ProofFailure, UnsatisfiedPrerequisites
from proveit._core_.defaults import defaults
from proveit.decorators import prover, equality_prover

class ExprRange(Expression):
    '''
    An ExprRange expression represents a range of "element" expressions
    within a containing ExprTuple.  It represents this as a Lambda to
    map each valid index value to a corresponding element, along with a
    start and end index value.  The represented element sequence
    corresponds to index values going from the start to the end in
    increments of 1, ranging over index values.

    For example,
    1/i + ... + 1/j
    is internall represented by an Add operation with the following as
    its "operands":
    (1/i, ..., 1/j).
    These "operands" are represented by an ExprTuple with a single
    "entry" which is an ExprRange whose `lambda_map` is "k |-> 1/k",
    `start_index` is "i", and `end_index` is "j".  An ExprTuple "entry"
    may generally either be a singuler element or an ExprRange that
    represents multiple elements.
    '''

    def __init__(self, parameter, body, start_index=None, end_index=None, 
                 *, true_start_index=None, true_end_index=None,
                 use_canonical_parameter=True, parameterization=None,
                 lambda_map=None, order=None, styles=None):
        '''
        Create an ExprRange that represents a range of expressions
        to be embedded within an ExprTuple.  Each element of the
        range is generated by mapping the parameter according to the
        body with the parameter ranging from the start index to the
        end index.
        A Lambda expression will be created as its first sub-expression.
        The start and end indices with be the second and third
        sub-expressions.

        Since the parameter used by the ExprRange is typically hidden
        (unless 'explicit' parameterization is used), we switch to a 
        canonical parameterization by default to for consistency-sake 
        and to avoid confusion.  If 'use_canonical_parameter' is set to
        False, the provided parameter will be used (desired on rare 
        occasions).

        The 'parameterization' sets the style for formatting the
        ExprRange.  The default is "implicit" for LaTeX formatting
        but "explicit" for string formatting.  Since string formatting
        is most often used for error messages, it is useful to have
        the full "explicit" version.

        The lambda_map may be used instead of supplying the parameter
        and body, in which case the 'parameter' and 'body' arguments
        must both be None.
        '''
        from proveit import Variable
        from proveit.numbers import Neg, negated, quick_simplified_index
        from proveit._core_.theory import UnsetCommonExpressionPlaceholder

        if order not in (None, 'decreasing', 'increasing'):
            raise ValueError("'order' must be 'increasing', "
                             "'decreasing', or None; not %s" % order)
        if order is not None:
            if styles is None: styles = dict()
            styles['order'] = order

        if body is not None:
            if isinstance(body, UnsetCommonExpressionPlaceholder):
                body.raise_attempted_use_error()
            body = single_or_composite_expression(
                    body, wrap_expr_range_in_tuple=False)
        
        if (start_index is None) == (true_start_index is None):
            if start_index is None:
                raise ValueError("Must provide either a 'start_index' or "
                                 "'true_start_index'")
            else:
                raise ValueError("Must provide either a 'start_index' or "
                                 "'true_start_index', not both")
        if (end_index is None) == (true_end_index is None):
            if end_index is None:
                raise ValueError("Must provide either a 'end_index' or "
                                 "'true_end_index'")
            else:
                raise ValueError("Must provide either a 'end_index' or "
                                 "'true_end_index', not both")
        if (start_index is None) != (end_index is None):
            raise ValueError(
                    "Provide either a 'start_index' and 'end_index' or "
                    "a 'true_start_index' and 'true_end_index'.  Mixing "
                    "is not allowed.")
        if true_start_index is None:
            if order == 'decreasing':
                # If the order is decreasing, negate the indices and the
                # parameter.
                true_start_index = negated(start_index)
                true_end_index = negated(end_index)
                if body is not None:
                    expr_map = {parameter: Neg(parameter),
                                Neg(parameter): parameter}
                    body = body.basic_replaced(expr_map)
            else:
                true_start_index = start_index
                true_end_index = end_index
                
        simp_true_start_index, simp_true_end_index = simplified_indices(
                true_start_index, true_end_index)
        if order == 'decreasing' and start_index is not None:
            (true_start_index, true_end_index) = (
                    simp_true_start_index, simp_true_end_index)
            decreasing_start_index = quick_simplified_index(
                    negated(true_start_index))
            decreasing_end_index = quick_simplified_index(
                    negated(true_end_index))
            if (start_index, end_index) != (decreasing_start_index, decreasing_end_index):
                raise ValueError(
                        "Decreasing start and end indices must be in the "
                        "'quick_simplified_index' canonical form: %s ≠ %s"
                        %((start_index, end_index),
                          (decreasing_start_index, decreasing_end_index)))
        else:
            if ((true_start_index, true_end_index)
                    != (simp_true_start_index, simp_true_end_index)):
                raise ValueError(
                        "Start and end indices must be in the "
                        "'quick_simplified_index' canonical form: %s ≠ %s"
                        %((true_start_index, true_end_index),
                          (simp_true_start_index, simp_true_end_index)))

        if lambda_map is not None:
            # Use the provided 'lambda_map' instead of creating one.
            lambda_map = lambda_map
            if (parameter, body) != (None, None):
                raise ValueError("'parameter' and 'body' arguments of the "
                                 "ExprRange constructor should be None if "
                                 "lambda_map is provided.")
            parameter = lambda_map.parameter
        else:
            if not isinstance(parameter, Variable):
                raise TypeError("The 'parameter' of an ExprRange must be "
                                "a Variable.")
            lambda_map = Lambda(parameter, body)
        if parameterization not in (None, 'implicit', 'explicit'):
            raise ValueError("'parameterization' must be 'implicit', "
                             "'explicit', or None; not %s" % parameterization)
        if parameterization is not None:
            if styles is None: styles = dict()
            styles['parameterization'] = parameterization

        for index in (start_index, end_index):
            if isinstance(index, UnsetCommonExpressionPlaceholder):
                index.raise_attempted_use_error()
                
        self.true_start_index = true_start_index = singular_expression(
                true_start_index)
        self.true_end_index = true_end_index = singular_expression(
                true_end_index)

        if use_canonical_parameter:
            # We'll use the parameter from the canonical version.
            # We won't use the canonical version itself, however,
            # or we would loose any style information.
            body = lambda_map.body
            orig_param = lambda_map.parameter
            param = lambda_map.canonically_labeled().parameter
            if orig_param != param:
                lambda_map = Lambda(
                    param, body.basic_replaced({orig_param:param}))

        self.lambda_map = lambda_map
        self.body = lambda_map.body
        self.parameter = lambda_map.parameter
        self.is_parameter_independent = (
            self.parameter not in free_vars(self.body))
        Expression.__init__(self, ['ExprRange'],
                            [lambda_map, true_start_index, true_end_index],
                            styles=styles)
        if true_start_index == true_end_index:
            raise ValueError(
                    "Do not create an ExprRange with the same start and "
                    "end index since it reduces to a single instance.  "
                    "Note that nested_range/var_range automatically "
                    "perform this reduction.")
        ExprRange._max_allowed_total_expansion(
                true_start_index, true_end_index,
                check_if_invalid=True)

    @property
    def start_index(self):
        '''
        The start index of the ExprRange depends upon whether or not 
        the order is decreasing in its style.
        '''
        from proveit.numbers import negated, quick_simplified_index
        if self.is_decreasing():
            return quick_simplified_index(negated(self.true_start_index))
        else:
            return self.true_start_index

    @property
    def end_index(self):
        '''
        The end index of the ExprRange depends upon whether or not 
        the order is decreasing in its style.
        '''
        from proveit.numbers import negated, quick_simplified_index
        if self.is_decreasing():
            return quick_simplified_index(negated(self.true_end_index))
        else:
            return self.true_end_index

    @classmethod
    def _make(sub_class, core_info, sub_expressions, *, styles):
        if sub_class != ExprRange:
            MakeNotImplemented(sub_class)
        if len(core_info) != 1 or core_info[0] != 'ExprRange':
            raise ValueError("Expecting ExprRange core_info to contain "
                             "exactly one item: 'ExprRange'")
        lambda_map, true_start_index, true_end_index = sub_expressions
        return ExprRange(None, None, 
                         true_start_index=true_start_index, 
                         true_end_index=true_end_index,
                         styles=styles, lambda_map=lambda_map)

    @staticmethod
    def _proper_sub_expr_replacements(orig_sub_exprs, subbed_sub_exprs):
        '''
        Given original sub-expressions and "subbed" (substituted) 
        sub-expressions for and ExprRange, return new subbed 
        sub-expressions that are revised appropriately if necessary to 
        nsure that the start and end indices are different, and the 
        start is the original version.
        '''
        start_index, end_index = subbed_sub_exprs[1:]
        if start_index == end_index:
            # Use the simplification for the start index,
            # but something equal to it but not the same expression
            # for the end index.
            if orig_sub_exprs[2] == start_index:
                assert orig_sub_exprs[1] != start_index, (
                    "start and end indices should not be the same")
                return (subbed_sub_exprs[0], subbed_sub_exprs[1],
                        orig_sub_exprs[1])
            else:
                return (subbed_sub_exprs[0], subbed_sub_exprs[1],
                        orig_sub_exprs[2])
                
        return subbed_sub_exprs

    def basic_replaced(self, repl_map, *, 
                       allow_relabeling=False, requirements=None,
                       _subbed_start_index=None,
                       _subbed_end_index=None):
        '''
        ExprRange.basic_replaced handles the case of reducing to
        a singular instance when start and end indices are the same.
        '''
        if len(repl_map) > 0 and (self in repl_map):
            replaced = repl_map[self]
        else:
            if _subbed_start_index is None:
                _subbed_start_index, _subbed_end_index = (
                        sub_expr.basic_replaced(
                            repl_map, allow_relabeling=allow_relabeling,
                            requirements=requirements)
                    for sub_expr in (self.true_start_index, self.true_end_index))
            else:
                assert _subbed_end_index is not None
            _subbed_start_index, _subbed_end_index = simplified_indices(
                     _subbed_start_index, _subbed_end_index,
                     requirements=requirements)
            if _subbed_start_index == _subbed_end_index:
                # Reduced to a single instance since the start and
                # end indices are the same.
                return self._singular_reduced(
                        repl_map, _subbed_index=_subbed_start_index,
                       allow_relabeling=allow_relabeling, 
                       requirements=requirements)
            sub_exprs = self._sub_expressions
            assert sub_exprs == (self.lambda_map, self.true_start_index,
                                 self.true_end_index)
            # Complete the subbed_sub_exprs
            # Assume the parameter condition.
            with defaults.temporary() as tmp_defaults:
                tmp_defaults.assumptions = (defaults.assumptions + 
                                            (self.parameter_condition(),))
                subbed_sub_exprs = (
                        self.lambda_map.basic_replaced(
                                repl_map, allow_relabeling=allow_relabeling,
                                requirements=requirements),
                        _subbed_start_index, _subbed_end_index)
            if all(subbed_sub._style_id == sub._style_id for
                   subbed_sub, sub in zip(subbed_sub_exprs, sub_exprs)):
                # Nothing change, so don't remake anything.
                return self
            replaced = self.__class__._checked_make(
                self._core_info, subbed_sub_exprs,
                style_preferences=self._style_data.styles)
        return replaced

    def _auto_simplified_sub_exprs(self, *, requirements, stored_replacements,
                                   markers_and_marked_expr):
        '''
        Properly handle the ExprRange scope while doing 
        auto-simplification replacements.  This combines the behavior
        of a Lambda and a Conditional.
        '''
        # Standard approach for the subbed indices.
        subbed_indices = \
            tuple(sub_expr_fn(self)._auto_simplified(
                    requirements=requirements, 
                    stored_replacements=stored_replacements,
                    markers_and_marked_expr=self._update_marked_expr(
                            markers_and_marked_expr, sub_expr_fn))
                  for sub_expr_fn in (
                          lambda _expr : _expr.true_start_index,
                          lambda _expr : _expr.true_end_index))
        parameter = self.parameter
        # Special assumptions for the body.  We can't use
        # assumptions involving the parameter except the
        # 'parameter condition' (that it is in an interval).
        inner_assumptions = \
            [assumption for assumption in defaults.assumptions if
             parameter not in free_vars(assumption)]
        inner_assumptions.append(self.parameter_condition())
        with defaults.temporary() as temp_defaults:
            temp_defaults.assumptions = inner_assumptions
            # Since the assumptions have changed, we can no longer use
            # the stored_replacements from before.
            subbed_body = self.body._auto_simplified(
                    requirements=requirements, 
                    stored_replacements=dict(),
                    markers_and_marked_expr=self._update_marked_expr(
                           markers_and_marked_expr,
                           lambda _expr : _expr.body))
            subbed_lambda = Lambda(parameter, subbed_body)
        subbed_sub_exprs = (subbed_lambda, *subbed_indices)
        sub_exprs = self._sub_expressions
        if all(subbed_sub._style_id == sub._style_id for
               subbed_sub, sub in zip(subbed_sub_exprs, sub_exprs)):
            # Nothing change, so don't remake anything.
            return self
        # This is an ExprRange.  If the start and end indices
        # are the same, force them to be different here
        # (we can't create an ExprRange where they are the same)
        # but it will be simplified in the containing ExprTuple
        # via a singlular range reduction.
        subbed_sub_exprs = ExprRange._proper_sub_expr_replacements(
            sub_exprs, subbed_sub_exprs)
        return self.__class__._checked_make(
            self._core_info, subbed_sub_exprs,
            style_preferences=self._style_data.styles)
        
    def _singular_reduced(self, repl_map, *, _subbed_index,
                       allow_relabeling=False, requirements=None):
        '''
        Return a basic replaced version where there is a singular
        reduction to the given _subbed_index.
        '''
        singular_instance = self.lambda_map.body.basic_replaced(
                            {self.parameter:_subbed_index},
                            requirements=requirements)
        return singular_instance.basic_replaced(
                repl_map, allow_relabeling=allow_relabeling,
                requirements=requirements)            

    def literal_int_extent(self):
        '''
        If the start and end indices of this ExprRange are literal integers,
        return the literal number of elements of the ExprRange.  For the
        case of nested ExprRange's, all of the start and end indices must
        be integers and the result will be the multiplied extent.  For
        example:
            a_{1,1}, ..., a_{1,3}, ......, a_{4,1}, ..., a_{4,3}
        has a literal_int_extent of 12.
        '''
        from proveit.numbers import is_numeric_int
        if (is_numeric_int(self.true_start_index) and is_numeric_int(self.true_end_index)):
            toplevel_extent = (
                self.true_end_index.as_int() -
                self.true_start_index.as_int() +
                1)
            if isinstance(self.body, ExprRange):
                return toplevel_extent * self.body.literal_int_extent()
            else:
                return toplevel_extent
        raise ValueError(
            "literal_int_extent may only be used on an ExprRange  "
            "with start and end indices that are literal integers")

    def remake_arguments(self):
        '''
        Yield the argument values or (name, value) pairs
        that could be used to recreate the ExprRange.
        '''
        yield self.lambda_map.parameter
        yield self.lambda_map.body
        yield self.true_start_index
        yield self.true_end_index
        # if self.get_style('order', 'increasing') == 'decreasing':
        #     yield ('order', r"'decreasing'")

    def remake_with_style_calls(self):
        '''
        In order to reconstruct this Expression to have the same styles,
        what "with..." method calls are most appropriate?  Return a
        tuple of strings with the calls to make.  The default for the
        Operation class is to include appropriate 'with_wrapping_at'
        and 'with_justification' calls.
        '''
        call_strs = []
        parameterization = self.get_style('parameterization', 'default')
        if parameterization != 'default':
            if parameterization == 'explicit':
                call_strs.append('with_explicit_parameterization()')
            if parameterization == 'implicit':
                call_strs.append('with_implicit_parameterization()')

        max_expansion = self._max_allowed_total_expansion(
            self.true_start_index, self.true_end_index)
        if max_expansion == 2:
            expansion_defaults = (1, 1)
        else:
            expansion_defaults = (2, 1)
        front_expansion = self.get_front_expansion()
        if front_expansion != expansion_defaults[0]:
            call_strs.append('with_front_expansion(%d)'%int(front_expansion))
        back_expansion = self.get_back_expansion()
        if back_expansion != expansion_defaults[1]:
            call_strs.append('with_back_expansion(%d)'%int(back_expansion))

        order = self.get_style('order')
        if order == 'decreasing':
            call_strs.append('with_decreasing_order()')

        wrap_positions = self.wrap_positions()
        if len(wrap_positions) > 0:
            call_strs.append('with_wrapping_at(' + ','.join(str(pos)
                                                            for pos in wrap_positions) + ')')

        case_simplify = self.get_style('case_simplify', 'False')
        if case_simplify != 'False':
            if case_simplify == 'True':
                call_strs.append('with_case_simplification()')
        return call_strs

    def style_options(self):
        from proveit.numbers import Add, one, zero
        options = StyleOptions(self)
        options.add_option(
            name='parameterization',
            description=(
                    "'implicit' (default for LaTeX formatting) hides "
                    "the parameter the ExprRange so the parameterization "
                    "may be ambiguous (e.g., x_{1+1}, ..., x_{n+1}); "
                    "'explicit' (default for string formatting) reveals "
                    "the parameterization "
                    "(e.g. x_{1+1}, ..x_{k+1}.., x_{n+1})."),
            default=None,
            related_methods=('with_explicit_parameterization',
                             'with_implicit_parameterization',
                             'with_default_parameterization_style'))
        if (Add(self.true_start_index, one).quick_simplified() !=
                Add(self.true_end_index, zero).quick_simplified()):
            # Front_expansion and back_expansion options are available
            # as long as this doesn't trivially/obviously have just 2 
            # elements. e.g., x_1, ..., x_2 should only use 1 for the
            # front and back expansion.
            options.add_option(
                name='front_expansion',
                description=(
                    "The number of instances to display at the front of the "
                    "range (e.g., before the ellipsis). Default is 2."),
                default=str(2),
                related_methods=('with_front_expansion', 'get_front_expansion'))
            options.add_option(
                name='back_expansion',
                description=(
                    "The number of instances to display at the back of the "
                    "range (e.g., after the ellipsis). Default is 1."),
                default=str(1),
                related_methods=('with_back_expansion', 'get_back_expansion'))
        options.add_option(
            name='order',
            description=(
                "The default order is 'increasing' (a_1 ... a_3) "
                "but to represent a 'decreasing' ExprRange (a_6 ... a_2) "
                "the order must be set to 'decreasing'"),
            default='increasing',
            related_methods=('with_decreasing_order', 'with_increasing_order'))
        options.add_option(
                name='wrap_positions',
                description=("position(s) at which wrapping is to occur; "
                             "'n' is after the nth comma."),
                default = '()',
                related_methods = ('with_wrapping_at',))
        options.add_option(
            name='case_simplify',
            description=(
                    "If 'True', simplify formatted instances "
                    "that are ConditionalSets under proper index "
                    "assumptions"),
            default='False',
            related_methods=('with_case_simplification',)
        )
        return options
    
    def with_explicit_parameterization(self):
        '''
        The 'parameterization':'explicit' style shows the
        parameterization of the ExprRange explicitly.  For example,
        x_{1+1}, ..x_{k+1}.., x_{n+1}).
        '''
        return self.with_styles(parameterization='explicit')

    def with_implicit_parameterization(self):
        '''
        The 'parameterization':'implicit' style does not show the
        parameterization of the ExprRange explicitly and such that the
        parameterization may be ambiguous but is more compact.
        For example, x_{1+1}, ..., x_{n+1} could be
        x_{1+1}, ..x_{k+1}.., x_{n+1}
        or could be
        x_{1+1}, ..x_{k}.., x_{n+1}.
        '''
        return self.with_styles(parameterization='implicit')

    def with_default_parameterization_style(self):
        '''
        The default is to use an 'implicit' parameterization for
        string formatting (see 'with_implicit_parameterization') and
        and 'explicit' parameterization for LaTeX formatting
        (see 'with_explicit_parameterization').
        '''
        return self.without_style('parameterization')

    def with_case_simplification(self):
        '''
        Simplify the formatted instances for the style.
        '''
        return self.with_styles(case_simplify='True')

    def with_decreasing_order(self):
        '''
        Used to indicate an ExprRange with decreasing order (a_4 ... a_2)
        '''
        return self.with_styles(order='decreasing')

    def with_increasing_order(self):
        '''
        Revert the order of an ExprRange so that the largest
        element is the last element
        '''
        return self.with_styles(order='increasing')
    
    def with_front_expansion(self, num):
        '''
        Set the number of instances to display at the front of the 
        range (e.g., before the ellipsis).
        '''
        if not isinstance(num, int) or num < 1:
            raise ValueError("front_expansion must be an integer of at "
                             "least 1")
        # Make sure the expansion doesn't induce an obvious overlap.
        self._check_obvious_expansion_overlap(
                num, self.get_back_expansion())
        # Note: 1 is the effective expansion when
        # 'front_expansion' is not a style option.
        if self.get_style('front_expansion', '1') != str(num):
            try:
                return self.with_styles(front_expansion=str(num))
            except StyleError:
                raise StyleError("'front_expansion' is not an applicable "
                                 "style option for this ExprRange: %s"%self)
        return self

    def with_back_expansion(self, num):
        '''
        Set the number of instances to display at the back of the 
        range (e.g., after the ellipsis).
        '''
        if not isinstance(num, int) or num < 1:
            raise ValueError("back_expansion must be an integer of at "
                             "least 1")
        self._check_obvious_expansion_overlap(
                num, self.get_back_expansion())
        # Note: 1 is the effective expansion when 
        # 'back_expansion' is not a style option.
        if self.get_style('back_expansion', '1') != str(num):
            try:
                return self.with_styles(back_expansion=str(num))
            except StyleError:
                raise StyleError("'back_expansion' is not an applicable "
                                 "style option for this ExprRange: %s"%self)
        return self
    
    def _check_obvious_expansion_overlap(
            self, front_expansion, back_expansion):
        max_allowed = self._max_allowed_total_expansion(
            self.true_start_index, self.true_end_index)
        if front_expansion + back_expansion > max_allowed:
            raise ValueError(
                "The front and back expansions are beyond the "
                "maximum allowed total expansion for %s: %d + %d > %d."
                %(self, front_expansion, back_expansion, max_allowed))

    @staticmethod
    def _max_allowed_total_expansion(start_index, end_index,
                                     check_if_invalid=False):
        from proveit.numbers.addition.add import split_int_shift
        start_base, start_shift = split_int_shift(start_index)
        end_base, end_shift = split_int_shift(end_index)
        if start_base == end_base:
            if end_shift+1 == start_shift:
                # For the special case of an empty ExprRange, we allow
                # a total expansion of 3.  Examples:
                #  a_1, a_2, ..., a_0
                #  a_n, a_{n-1}, ..., a_{n+1}
                return 3
            if check_if_invalid and end_shift < start_shift-1:
                raise ValueError("Invalid ExprRange endpoints: %s to %s"
                                 %(start_index, end_index))
            return max(end_shift - start_shift + 1, 2)
        # No limit since there is no obvious overlap.
        return float('inf')

    def with_wrapping_at(self, *wrap_positions):
        return self.with_styles(
            wrap_positions='(' +
            ' '.join(
                str(pos) for pos in wrap_positions) +
            ')')

    def get_front_expansion(self):
        '''
        Get the number of instances to display at the front of the 
        range (e.g., before the ellipsis).
        '''
        return int(self.get_style('front_expansion', 1))

    def get_back_expansion(self):
        '''
        Get the number of instances to display at the back of the 
        range (e.g., after the ellipsis).
        '''
        return int(self.get_style('back_expansion', 1))
    
    def is_decreasing(self):
        return self.get_style('order') == 'decreasing'

    def wrap_positions(self):
        '''
        Return a list of wrap positions according to the current style 
        setting.  Position 'n' is after the nth comma.
        '''
        return [int(pos_str) for pos_str in self.get_style(
            'wrap_positions', '').strip('()').split(' ') if pos_str != '']

    def instance_context(self, index_base, index_shift):
        '''
        Returns in InstanceContext context manager which contains
        the instance of the ExprRange corresponding to the index
        set at index_base+index_shift where index_base is an Expression
        and index_shift is an integer.  The InstanceContext contains
        the 'instance' (body replaced with the appropriate index and
        with case simplification as appropriate) and maintains 
        temporary assumptions and disabled automation until the context
        is exited.  These temporary settings may be useful for handling
        case simplifications of nested ExprRanges.
        '''
        try:
            temp_defaults = defaults.temporary()
            temp_defaults.automation = False
            temp_defaults.preserve_all = True
            return self._instance_context(index_base, index_shift,
                                          temp_defaults)
        except Exception as e:
            # We weren't able to return the instance context,
            # so make sure we exit the temp_defaults context.
            with temp_defaults:
                pass
            raise e

    def _instance_context(self, index_base, index_shift, temp_defaults):
        '''
        Helper for ExprRange.instance_context
        '''

        from proveit import ConditionalSet
        from proveit.relation import Relation
        from proveit.logic import Not, Equals, NotEquals, InSet
        from proveit.numbers import (
                Less, num, Add, Interval, Neg, negated,
                quick_simplified_index)
        from proveit.numbers.addition.add import split_int_shift
        
        if not isinstance(index_base, Expression):
            raise TypeError("'index_base' must be an Expression")
        if not isinstance(index_shift, int):
            raise TypeError("'index_shift' must be an integer")

        order = self.get_style("order", "increasing")
        decreasing = (order == 'decreasing')
        if decreasing:
            neg_index_base = negated(index_base)
            if index_shift == 0:
                index = Neg(quick_simplified_index(neg_index_base))    
            else:
                index = Neg(quick_simplified_index(Add(neg_index_base, 
                                                       num(-index_shift))))
        else:
            if index_shift == 0:
                index = quick_simplified_index(index_base)
            else:
                index = quick_simplified_index(Add(index_base, num(index_shift)))
        if decreasing:
            expr_map = {Neg(self.lambda_map.parameter): index.operand,
                        self.lambda_map.parameter: index}
        else:
            expr_map = {self.lambda_map.parameter: index}
        # For purposes of displaying/exploring, we will assume
        # that the expanded indices are in a proper order and that
        # the front expansion does not overlap with the back expansion.
        assumptions = []
        if decreasing:
            # Negate the indices when in decreasing mode.
            index = quick_simplified_index(Neg(index))
            start_base, start_shift = split_int_shift(
                    negated(self.true_start_index))
            end_base, end_shift = split_int_shift(
                    negated(self.true_end_index))         
            sign = -1
        else:
            index = quick_simplified_index(index)
            start_base, start_shift = split_int_shift(self.true_start_index)
            end_base, end_shift = split_int_shift(self.true_end_index)
            sign = 1
        index_base, index_shift = split_int_shift(index)
        if index_base not in (start_base, end_base):
            raise ValueError(
                    "'index' %s must be a literal integer shift "
                    "from %s or %s"%(index, start_base, end_base))
        for base, other_shift_range in (
                (start_base, range(
                        sign*start_shift, 
                        sign*start_shift+self.get_front_expansion())),
                (end_base, range(
                        sign*end_shift-self.get_back_expansion()+1, 
                        sign*end_shift+1))):
            for other_shift in other_shift_range:
                other_shift = sign*other_shift
                if other_shift == 0:
                    other_index = quick_simplified_index(base)
                else:
                    other_index = quick_simplified_index(
                            Add(base, num(other_shift)))
                if index_base == base:
                    if other_shift == index_shift:
                        assert index == other_index, (
                            "base: %s, other_shift: %s"%(base, other_shift))
                        # Trivial, but include it anyways so
                        # we won't need any automation:
                        assumptions.append(Equals(index, other_index))
                    else:
                        assumptions.append(NotEquals(index, other_index))
                        if other_shift < index_shift:
                            assumptions.append(Less(other_index, index))
                        else:
                            assumptions.append(Less(index, other_index))
                else:
                    if base == start_base:
                        assumptions.append(Less(other_index, index))
                    else:
                        assumptions.append(Less(index, other_index))
                    assumptions.append(NotEquals(index, other_index))
        # To avoid automation, we need to include many variants.
        net_assumptions = list(defaults.assumptions)
        for assumption in assumptions:
            net_assumptions.append(assumption)
            lhs, rhs = assumption.operands
            if isinstance(assumption, Equals):
                net_assumptions.append(Not(NotEquals(lhs, rhs)))
                if lhs != rhs:
                    net_assumptions.append(Equals(rhs, lhs))
                    net_assumptions.append(Not(NotEquals(rhs, lhs)))
            if isinstance(assumption, NotEquals):
                net_assumptions.append(Not(Equals(lhs, rhs)))
                if lhs != rhs:
                    net_assumptions.append(NotEquals(rhs, lhs))
                    net_assumptions.append(Not(Equals(rhs, lhs)))
            if isinstance(assumption, Less):
                net_assumptions.append(Not(Less(rhs, lhs)))
        temp_defaults.assumptions = net_assumptions
        instance = self.body.basic_replaced(expr_map)
        if self.get_style('case_simplify') == 'True':
            if isinstance(instance, ConditionalSet):
                # Effect the simplification of the conditional set
                # if possible without automation and with no proof
                # (display/inspection purposes only).
                new_conditionals = []
                for conditional_entry in instance.conditionals:
                    conditional = conditional_entry
                    extra_assumptions = []
                    while isinstance(conditional, ExprRange):
                        # A range of conditionals: add the 
                        # assumption that the range parameter is
                        # within the Interval and dig into the body.
                        extra_assumptions.append(
                                InSet(conditional.parameter,
                                      Interval(conditional.true_start_index,
                                               conditional.true_end_index)))
                        conditional = conditional.body
                    if isinstance(conditional, Conditional):
                        # Check the condition of the conditional.
                        # If proven, use just the value.
                        # If disproven, skip this entry.
                        condition = conditional.condition
                        if isinstance(condition, Relation):
                            # If the condition is a Relation,
                            # 'quick simplify' any side that is an
                            # Add.
                            lhs, rhs = condition.lhs, condition.rhs
                            new_lhs, new_rhs = lhs, rhs
                            new_lhs = quick_simplified_index(lhs)
                            new_rhs = quick_simplified_index(rhs)
                            if lhs != new_lhs or rhs != new_rhs:
                                condition = condition.basic_replaced(
                                        {lhs:new_lhs, rhs:new_rhs})
                        if len(extra_assumptions) > 0:
                            with defaults.temporary() as tmp_defaults2:
                                tmp_defaults2.assumptions = (
                                        defaults.assumptions +
                                        extra_assumptions)
                                proven_condition = condition.proven()
                                disproven_condition = condition.disproven()
                        else:
                            proven_condition = condition.proven()
                            disproven_condition = condition.disproven()
                        if proven_condition:
                            new_conditionals.append(conditional.value)
                            continue
                        elif disproven_condition:
                            # Skip over this conditional with the
                            # false condition.
                            continue
                    new_conditionals.append(conditional_entry)
                if len(new_conditionals) == 1:
                    # All but one condition is disproven.  If the
                    # remaining condition is proven, this will be
                    # the value of that conditional.
                    instance = new_conditionals[0]
                elif tuple(new_conditionals) != instance.conditionals:
                    # Create the simplified ConditionalSet.
                    instance = ConditionalSet(*new_conditionals)
        # This quick simplification hides too much.
        #if isinstance(instance, Add) or isinstance(instance, Neg):
        #    instance = instance.quick_simplified()
        return InstanceContext(instance, temp_defaults)

    def first(self):
        '''
        Return the first instance of the range.
        '''
        with self.instance_context(self.true_start_index, 0) as ic:
            return ic.instance

    def last(self):
        '''
        Return the last instance of the range.
        '''
        with self.instance_context(self.true_end_index, 0) as ic:
            return ic.instance

    def format_length(self):
        '''
        The length of the ExprRange when it is formatted according to the expansion.
        '''
        return self.get_front_expansion() + 1 + self.get_back_expansion()

    def string(self, **kwargs):
        return self.formatted('string', **kwargs)

    def latex(self, **kwargs):
        return self.formatted('latex', **kwargs)

    def parameter_condition(self):
        from proveit.logic import InSet
        from proveit.numbers import Interval
        return InSet(self.parameter,
                Interval(self.true_start_index, 
                         self.true_end_index))

    def nested_range_depth(self):
        '''
        Return the depth of nested ranges.  For example, if this
        is a simple range with no nesting, return 1.
        If this is a range of simple ranges, return 2.
        If this is a range of ranges of simple ranges, return 3.
        '''
        depth = 1
        expr = self.body
        while isinstance(expr, ExprRange):
            depth += 1
            expr = expr.body
        return depth

    def _use_explicit_parameterization(self, format_type):
        '''
        Return True iff explicit parameterization should be used
        for the given format type given the 'style' settings.
        The default using 'explicit' for 'string' format and 'implicit'
        for 'latex' format.
        '''
        default_style = ("explicit" if format_type == 'string' else 'implicit')
        if (self.get_style("parameterization", default_style) == "explicit"):
            return True
        return False

    def _formatted_entries(self, format_type, *,
                           operator_or_operators=',',
                           implicit_first_operator=False):
        if (isinstance(operator_or_operators, ExprRange) and
                operator_or_operators.is_parameter_independent):
            operator_or_operators = operator_or_operators.body
        def inf_repeat_iter(x):
            while True:
                yield x
        if isinstance(operator_or_operators, ExprRange):
            operator_or_operators = (
                    operator_or_operators.with_mimicked_style(self))
            formatted_operator_entries = []
            operator_or_operators._append_format_cell_entries(
                    formatted_operator_entries)
            # Grab just the expression, not the "role".
            formatted_operators = []
            for (_expr, _), assumptions in (
                    operator_or_operators.yield_format_cell_info()):
                with defaults.temporary() as tmp_defaults:
                    tmp_defaults.automation = False
                    tmp_defaults.assumptions = assumptions
                    formatted_operators.append(_expr.formatted(format_type))
            formatted_operators_iter = iter(formatted_operators)
        elif isinstance(operator_or_operators, Expression):
            _operator = operator_or_operators.formatted(format_type)
            formatted_operators_iter = inf_repeat_iter(_operator+' ')
        else:
            formatted_operators_iter = inf_repeat_iter(operator_or_operators)
        formatted_entries = []
        for (expr, role), assumptions in self.yield_format_cell_info():
            formatted_operator = next(formatted_operators_iter)
            if implicit_first_operator and len(formatted_entries)==0:
                formatted_operator = ''
            with defaults.temporary() as tmp_defaults:
                tmp_defaults.assumptions = assumptions
                if isinstance(expr, ExprRange):
                    nested_range_depth = expr.nested_range_depth()
                else:
                    nested_range_depth = 1
                if len(formatted_entries) > 0:
                    if formatted_operator != ',':
                        formatted_operator = ' ' + formatted_operator
                    formatted_operator = formatted_operator + ' '
                if role == 'implicit':
                    ellipsis = ('\ldots' if format_type == 'latex'
                                else '...')
                    ellipsis = ellipsis * nested_range_depth
                    formatted_entries.append([formatted_operator, ellipsis])
                else:
                    ellipsis = '..' * nested_range_depth
                    if role == 'param_independent':
                        formatted_entries.append(
                                [formatted_operator,
                                 ellipsis + expr.formatted_repeats(format_type) 
                                 + ellipsis])
                    elif role == 'explicit':
                        formatted_body = expr.body.formatted(format_type,
                                                             fence=True)    
                        formatted_entries.append(
                                [formatted_operator,
                                 ellipsis + formatted_body + ellipsis])
                    else:
                        formatted_expr = expr.formatted(format_type,
                                                        fence=True)
                        formatted_entries.append([formatted_operator,
                                                  formatted_expr])
        return formatted_entries

    def formatted(self, format_type, **kwargs):
        wrap_positions = self.wrap_positions()
        justification = 'left'
        return ExprTuple(self).formatted(format_type,
                 fence=False, sub_fence=True,
                 operator_or_operators=',',
                 implicit_first_operator=True,
                 wrap_positions=wrap_positions,
                 justification=justification)

    def num_elements(self, proven=True, **defaults_config):
        '''
        Return the number of elements represented by this ExprRange.
        This includes the extent of all contained ranges.
        If proven==True, a proof is constructed in the process.
        '''
        from .expr_range import ExprRange
        from proveit.core_expr_types import Len
        from proveit.numbers import Add, Mult, Neg, one
        if proven:
            return Len(ExprTuple(self)).computed(**defaults_config)
        multiplier = None
        if isinstance(self.body, ExprRange):
            # Nested ExprRanges
            num_body_elements = self.body.num_elements(proven=False)
            if self.is_parameter_independent:
                # We can simply multiply counts when the nested
                # ExprRange is independent of our parameter.
                multiplier = num_body_elements
            else:
                # Return a sum over an appropriate ExprRange.
                if (isinstance(num_body_elements, Add) and
                        num_body_elements.terms.num_entries()==1 and
                        isinstance(num_body_elements.terms[0], Add)):
                    # Ungroup this sum over an ExprRange.
                    num_body_elements = num_body_elements.terms[0]
                return Add(ExprRange(self.parameter, num_body_elements,
                                     true_start_index=self.true_start_index, 
                                     true_end_index=self.true_end_index,
                                     styles=self.get_styles()))
        # count = (end_index - start_index) + 1
        count = Add(self.true_end_index, 
                    Neg(self.true_start_index), one).quick_simplified()
        if multiplier is not None:
            if isinstance(multiplier, Mult):
                return Mult(*([count] + multiplier.factors))
            return Mult(count, multiplier)
        return count
    
    def yield_format_cell_info(self):
        '''
        Yield information pertaining to each format cell of this
        ExprRange in the format:
            ((expr, role), assumptions)
        The expr is the Expression of the entry.  Temporary assumptions
        are made about the comparison of ExprRange indices at distinct
        format cells (useful from case simplification of nested
        ExprRanges) and yielded.  The 'role' is defined as follows.
        The beginning cells of the ExprRange will have consecutive 
        integers for their role  starting with 0, the last cell has -1 
        for its role, and the 'ellipsis' cell has 'implicit', 
        'explicit', or 'param_independent' for its role depending upon
        whether it is parameter independent and, if not, the 
        'parameterization' style option of the ExprRange.
        '''
        front_expansion = self.get_front_expansion()
        back_expansion = self.get_back_expansion()
        start_index = self.true_start_index
        end_index = self.true_end_index
        for _k in range(0, front_expansion):
            with self.instance_context(start_index, _k) as instance_context:
                next_entry = instance_context.instance
                if isinstance(next_entry, ExprRange):
                    # Recurse through the entries of an inner ExprRange.
                    for inner_entry_and_assumptions in \
                            next_entry.yield_format_cell_info():
                        yield inner_entry_and_assumptions
                else:
                    # Yield the next entry and corresponding assumptions
                    yield (next_entry, _k), defaults.assumptions
        if self.is_parameter_independent:
            yield (self, "param_independent"), defaults.assumptions
        else:
            parameterization = self.get_style('parameterization',
                                              'implicit')
            yield (self, parameterization), defaults.assumptions
        for _k in range(-back_expansion, 0):
            with self.instance_context(end_index, _k+1) as instance_context:
                next_entry = instance_context.instance
                if isinstance(next_entry, ExprRange):
                    # Recurse through the entries of an inner ExprRange.
                    for inner_entry_and_assumptions in\
                            next_entry.yield_format_cell_info():
                        yield inner_entry_and_assumptions
                else:
                    # Append the next entry.
                    yield (next_entry, _k), defaults.assumptions

    def _append_format_cell_element_positions(
            self, start_element_pos, element_positions):
        '''
        Append to a list of element positions in correspondence with
        each format cell of an ExprTuple containing this ExprRange
        (see ExprTuple.yield_format_cell_info).
        Start with the given start_pos as the first position of the
        ExprRange.  The element position of an 'ellipsis' cell is
        'None' (it isn't defined).  The element position of the last
        cell will be ('end_index' - 'start_index') of the ExprRange
        added to the element position of the first cell.
        '''
        from proveit.numbers import Add, Neg, one, num
        element_pos = start_element_pos
        front_expansion = self.get_front_expansion()
        back_expansion = self.get_back_expansion()
        start_index = self.true_start_index
        end_index = self.true_end_index
        nested_ranges = isinstance(self.body, ExprRange)
        # Do the front expansion.
        for _k in range(0, front_expansion):
            if _k > 0:
                element_pos = Add(element_pos, one).quick_simplified()
            if nested_ranges:
                with self.instance_context(start_index, _k) as ic:
                    next_entry = ic.instance
                    # Use recursion for a nested ExprRange.
                    element_pos= (
                            next_entry._append_format_cell_element_positions(
                                    element_pos, element_positions))
            else:
                # Append the next element position.
                element_positions.append(element_pos)
        # Use None for the 'ellipsis' cell:
        element_positions.append(None) 
        # Set 'element_pos' to just before the first of the back
        # expansion.  Do this by going to the very end and then
        # backtracking.
        net_range_len = self.num_elements(proven=False)
        element_pos = Add(start_element_pos, net_range_len, 
                          num(-1)).quick_simplified()
        for _k in range(-back_expansion, 0):
            with self.instance_context(end_index, _k+1) as ic:
                entry = ic.instance
                range_len = ExprTuple(entry).num_elements(proven=False)
             # back up
            element_pos = Add(element_pos, Neg(range_len)).quick_simplified()
        # Do the back expansion.
        for _k in range(-back_expansion, 0):
            element_pos = Add(element_pos, one).quick_simplified()
            if nested_ranges:
                with self.instance_context(end_index, _k+1) as ic:
                    next_entry = ic.instance
                    # Use recursion for a nested ExprRange.
                    element_pos= (
                            next_entry._append_format_cell_element_positions(
                                    element_pos, element_positions))
            else:
                # Append the next element position.
                element_positions.append(element_pos)
        return element_pos
    
    def formatted_repeats(self, format_type):
        from proveit.numbers import Add, Neg, num
        if not self.is_parameter_independent:
            raise ValueError("'formatted_repeats' intended to be used only "
                             "when the parameter is independent.")
        after_front_expansion = Add(self.true_start_index, 
                                    num(self.get_front_expansion()))
        first_of_back_expansion = Add(self.true_end_index, 
                                      num(-self.get_back_expansion()+1))
        between_count = Add(
                first_of_back_expansion, 
                Neg(after_front_expansion)).quick_simplified()
        repeats_str = r' \times' if format_type=='latex' else ' ×'
        return '%s%s' % (between_count.formatted(format_type, fence=True),
                         repeats_str)

    def _free_var_ranges(self, exclusions=None):
        '''
        Return the dictionary mapping Variables to forms w.r.t. ranges
        of indices (or solo) in which the variable occurs as free
        (not within a lambda map that parameterizes the base variable).
        Examples of "forms":
            x
            x_i
            x_1, ..., x_n
            x_{i, 1}, ..., x_{i, n_i}
            x_{1, 1}, ..., x_{1, n_1}, ......, x_{m, 1}, ..., x_{m, n_m}

        If this Expression is in the exclusion set, or contributes
        directly to a form that is in the exclusions set, skip over it.
        For example, given the expression
            a*x_{i, 1} + ... + a*x_{i, n_1}
        if x_{i, 1}, ..., x_{i, n_i} is in the exclusion set,
        then 'a' will be the only free variable reported.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var
        if exclusions is not None:
            if self in exclusions:
                return dict()  # this is excluded
            # For the body, extend the exclusion set as necessary to
            # exclude anything contributing directly to a form that is
            # in the exclusion set.  For example, if
            # x_1, ..., x_n is in the exclusion set and
            # self.parameter==k and self.true_start_index==1 and
            # self.true_end_index==n then add x_k to the exclusion set of
            # this body.
            body_exclusions = set(exclusions)
            for exclusion in exclusions:
                if (isinstance(exclusion, ExprRange) and
                        exclusion.true_start_index == self.true_start_index and
                        exclusion.true_end_index == self.true_end_index):
                    new_exclusion = exclusion.body.basic_replaced(
                        {exclusion.parameter: self.parameter})
                    body_exclusions.add(new_exclusion)
        else:
            body_exclusions = None
        body_forms_dict = \
            self.body._free_var_ranges(exclusions=body_exclusions)
        # deep copy body_forms_dict into forms_dict
        forms_dict = {var: set(ranges) for var, ranges
                      in body_forms_dict.items()}
        param = self.parameter
        # Eliminate the parameter; it is not a free variable.
        if param in forms_dict.keys():
            forms_dict[param].discard(param)
            if len(forms_dict[param]) == 0:
                forms_dict.pop(param)
        for expr in self._sub_expressions[1:]:
            # Skip the first sub-expression. We've already treated that.
            for var, forms in expr._free_var_ranges(
                    exclusions=exclusions).items():
                forms_dict.setdefault(var, set()).update(forms)
        # The var ranges of the body that depend upon self.parameter
        # will be promoted to expression ranges over the range of this
        # ExprRange.  For example, if x_k is one of the var ranges of
        # the body and self.parameter==k, then x_k will be replaced
        # by x_1, ..., x_n.
        for parameterized_var_range in self._parameterized_var_ranges(
                body_forms_dict):
            var = get_param_var(parameterized_var_range)
            assert var in forms_dict
            forms_dict[var].remove(parameterized_var_range)
            forms_dict[var].add(
                    ExprRange(param, parameterized_var_range,
                              true_start_index=self.true_start_index, 
                              true_end_index=self.true_end_index,
                              styles=self.get_styles()))
        return forms_dict

    def _parameterized_var_ranges(self, body_forms_dict=None):
        '''
        Yield each of body._free_var_ranges() that involves the
        ExprRange parameter as a free variable.
        For example, for ((x_1 < x_{1+1}) and ... and (x_n < x_{n+1})),
        the following will be yielded if k is the ExprRange parameter:
            x_k, x_{k+1}.
        Another example:
            a*x_{1, 1} + ... + a*x_{1, n_1} + ......
                + a*x_{m, 1} + ... + a*x_{m, n_1}
        will give
            x_{i, 1}, ..., x_{i, n_i}
        if i is the ExprRange parameter.
        '''
        if body_forms_dict is None:
            body_forms_dict = self.body._free_var_ranges()
        param = self.parameter
        for var, forms in body_forms_dict.items():
            for form in forms:
                if form == self:
                    continue
                if form == self.parameter:
                    continue  # don't count the parameter itself.
                var_forms_of_form = form._free_var_ranges()
                if (param in var_forms_of_form
                        and param in var_forms_of_form[param]):
                    yield form

    @equality_prover("reduced", "reduce")
    def reduction(self, must_reduce=False, **defaults_config):
        '''
        Prove this ExprRange, wrapped in an ExprTuple, equal
        to an ExprTuple form that is possibly reduced after simplifying
        indices.  An apparently empty ExprRange will be collapsed to an
        empty ExprRange.  A parameter-independent ExprRange will be
        shifted so to start from an index of 1.
        '''
        from proveit import f, i, j, m, n
        from proveit.logic import Equals
        from proveit.numbers import Add, one
        tuple_wrapped_self = ExprTuple(self)
        lambda_map = self.lambda_map
        start_index = self.true_start_index
        end_index = self.true_end_index
        start_index_simplification = start_index.simplification()
        end_index_simplification = end_index.simplification()
        simp_start_index = start_index_simplification.rhs
        simp_end_index = end_index_simplification.rhs
        index_replacements = []
        if simp_start_index != start_index:
            index_replacements.append(start_index_simplification)
        if simp_end_index != end_index:
            index_replacements.append(end_index_simplification)
        replacements = defaults.replacements + tuple(index_replacements)
        if Equals(simp_start_index, simp_end_index).proven():
            # If we know that the start and end index are the
            # same, we can use the singular_range_reduction.
            from proveit.core_expr_types.tuples import \
                singular_range_reduction
            # return self.singular_range_reduction(
            #     {f:lambda_map, i:start_index, j:end_index},
            #      preserve_expr=tuple_wrapped_self)
            return singular_range_reduction.instantiate(
                {f:lambda_map, i:start_index, j:end_index},
                 replacements=replacements,
                 preserve_expr=tuple_wrapped_self)
        # If the start and end are literal integers and form an
        # empty range, then it should be straightforward to
        # prove that the range is empty.
        from proveit.numbers import is_numeric_int
        default_order = 'increasing'
        if self.get_style('order', default_order) == 'decreasing':
            decreasing = True
        else:
            decreasing = False
        empty_req = Equals(Add(simp_end_index, one), simp_start_index)
        if is_numeric_int(simp_start_index) and is_numeric_int(simp_end_index):
            if simp_end_index.as_int() + 1 == simp_start_index.as_int():
                empty_req.prove()
        first = self.first()
        if empty_req.proven():
            # Make sure we prove it for the original indices.
            if simp_start_index != start_index:
                empty_req = start_index_simplification.sub_left_side_into(
                        empty_req.inner_expr().rhs)
            if simp_end_index != end_index:
                empty_req = end_index_simplification.sub_left_side_into(
                        empty_req.inner_expr().lhs.terms[0])            
            # We can do an empty range reduction
            # Temporarily disable automation to avoid infinite
            # recursion.
            if self.nested_range_depth() > 1:
                # this is a nested range, but we know
                # that the outer range reduces to an empty range,

                # We can do an empty range reduction on the entire expression
                # Temporarily disable automation to avoid infinite
                # recursion.
                from proveit.core_expr_types.tuples import \
                    empty_outside_range_of_range
                nest_end_index = first.true_end_index
                nest_start_index = first.true_start_index
                lambda_map = Lambda(
                    (self.parameter, self.body.parameter), self.body.body)
                if decreasing:
                    return empty_outside_range_of_range.instantiate(
                        {f: lambda_map, m: start_index, n: end_index,
                         i: nest_start_index, j: nest_end_index},
                         preserve_expr=tuple_wrapped_self).inner_expr().lhs[0].with_decreasing_order()
                else:
                    return empty_outside_range_of_range.instantiate(
                        {f: lambda_map, m: start_index, n: end_index,
                         i: nest_start_index, j: nest_end_index},
                        preserve_expr=tuple_wrapped_self)
            else:
                from proveit.core_expr_types.tuples import \
                    empty_range_def
                # Preserve 'self' on the left side of the reduction.
                if decreasing:
                    empty_range = empty_range_def.instantiate(
                        {f: lambda_map, i: start_index, j: end_index},
                        preserve_expr=tuple_wrapped_self)
                    return empty_range.inner_expr().lhs[0].with_decreasing_order()
                else:
                    return empty_range_def.instantiate(
                        {f: lambda_map, i: start_index, j: end_index},
                        preserve_expr=tuple_wrapped_self)
        elif self.nested_range_depth() > 1:
            # this is a nested range so the inner range could be empty.

            # If the start and end of the inner range are literal
            # integers and form an empty range, then it should be
            # straightforward to prove that the entire range is empty.
            from proveit.numbers import is_numeric_int
            empty_req = Equals(
                Add(first.true_end_index, one), first.true_start_index)
            if is_numeric_int(
                    first.true_start_index) and is_numeric_int(
                    first.true_end_index):
                if first.true_end_index.as_int() + \
                        1 == first.true_start_index.as_int():
                    empty_req.prove()
            if empty_req.proven():
                # We can do an empty range reduction on the entire expression
                # Temporarily disable automation to avoid infinite
                # recursion.
                from proveit.core_expr_types.tuples import \
                    empty_inside_range_of_range
                # Preserve 'self' on the left side of the reduction.
                nest_end_index = first.true_end_index
                nest_start_index = first.true_start_index
                lambda_map = Lambda(
                    (self.parameter, self.body.parameter), 
                    self.body.body)
                reduction = empty_inside_range_of_range.instantiate(
                    {f: lambda_map, m: start_index, n: end_index,
                     i: nest_start_index, j: nest_end_index},
                    preserve_expr=tuple_wrapped_self)
                if decreasing:
                    return (reduction.inner_expr().lhs[0]
                            .with_decreasing_order())
                else:
                    return reduction

        # If the ExprRange is parameter independent, shift it
        # so the index starts at 1, increasing.
        if self.is_parameter_independent and (self.is_decreasing() or
                                              self.start_index != one):
            expr = self
            if expr.is_decreasing():
                expr = expr.with_increasing_order()
            return expr.shift_equivalence(new_start=one)
        
        # If nothing else is applicable, we will return the trivial 
        # reflexive equality.
        if must_reduce:
            # Nothing can be reduced, so raise an exception.
            raise UnsatisfiedPrerequisites("%s is not provably "
                                           "reducible"%self)
        reduction = Equals(tuple_wrapped_self, 
                           tuple_wrapped_self).conclude_via_reflexivity()
        if len(index_replacements) > 0:
            if simp_start_index != start_index:
                reduction = start_index_simplification.sub_right_side_into(
                        reduction.inner_expr().rhs[0].true_start_index)
            if simp_end_index != end_index:
                reduction = end_index_simplification.sub_right_side_into(
                        reduction.inner_expr().rhs[0].true_end_index)      
        return reduction
    
    def _replaced_entries(self, repl_map, allow_relabeling, requirements):
        '''
        Returns this expression with sub-expressions replaced
        according to the replacement map (repl_map) dictionary.

        'requirements' (and defaults.assumptions) are used when an 
        operator is replaced by a Lambda map that has a range of 
        parameters such that the length of the parameters and operands 
        must be proven to be equal.  See the Operation.replaced and 
        Lambda.apply documentation for more details.
        
        If the start and end indices of the ExprRange are replaced
        with the same expression, just the single instance will
        be yielded.

        Expansion replacements of a range of indexed variables must
        be made explicit for the corresponding range (and therefore
        unambiguous and direct).  For example, to expand x in the
        following expression
            (x_1 < x_{1+1}) and ... and (x_n < x_{n+1})
        there must be a replacement in repl_map for
        (x_1, ..., x_n) as well as (x_{1+1}, ..., x_{n}).
        In an instantiation, this can be done by supplying
        instantiations of multiple forms of ranges of x.  For example:
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{1+1}, ..., d_{n+1})
        where the following requirements must be satisfied:
            (1, ..., n, n+1) = (1, ..., n+1)
            (1, 1+1, ..., n+1) = (1, ..., n+1)
            (a_1, ..., a_n, b) = (c, d_{1+1}, ..., d_{n+1})

        When multiple indexed variables are expanded within the
        ExprRange, the expansions must be in exact correspondence
        with respect to range start and index indices of the expansion.
        The above example meets this requirement since
            a_1, ..., a_n
            matches with
            b_{1+1}, ..., b_{n+1}
            by both being ranges from 1 to n.
        This expansion would fail this requirement
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{2}, ..., d_{n+1})
        since d_{2}, ..., d_{n+1} is a range from 2 to n+1.

        Here is another valid instantiation:
            (x_1, ..., x_n, x_{n+1}) :
                (a_1, ..., a_n, a_{n+1}, b_1, ..., b_n, b_{n+1})
            (x_1, x_{1+1}, ..., x_{n+1}) :
                (a_1, a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1})
        since
             a_1, ..., a_n, a_{n+1}, b_1, ..., b_n
             matches with
             a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1}
             with the pattern: 1 to n, single element, 1 to n.

        See the Lambda.apply documentation for a related discussion.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var, extract_param_replacements
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.logic import Equals, InSet
        from proveit.numbers import (Add, subtract, one, Interval,
                                     Integer, quick_simplified_index)

        if len(repl_map) > 0 and (self in repl_map):
            # The full expression is to be replaced.
            return repl_map[self]

        # Do replacements for the start and end indices.
        subbed_start_index, subbed_end_index = (
                sub_expr.basic_replaced(
                    repl_map, allow_relabeling=allow_relabeling,
                    requirements=requirements)
            for sub_expr in (self.true_start_index, self.true_end_index))
        # See if we should reduce to a singular instance, according to
        # whether the start and end indices are the same.
        if subbed_start_index==subbed_end_index:
            yield self._singular_reduced(
                    repl_map, _subbed_index=subbed_start_index,
                    allow_relabeling=allow_relabeling,
                    requirements=requirements)
            return
        
        subbed_styles = self.get_styles()
        # Figure out what front/back expansions are allowed for the
        # styles.
        max_total_expansion = ExprRange._max_allowed_total_expansion(
                subbed_start_index, subbed_end_index)
        #if self.is_parameter_independent or max_total_expansion == 2:
        if max_total_expansion == 2:
            # The front and back expansions after substituting must
            # each be 1, so exclude them from the style options.
            subbed_styles.pop('front_expansion', None)
            subbed_styles.pop('back_expansion', None)
        else:
            front_expansion, back_expansion = (self.get_front_expansion(),
                                               self.get_back_expansion())
            if front_expansion+back_expansion > max_total_expansion:
                # We must restrict the front and back expansions.
                subbed_styles['front_expansion'] = min(
                        front_expansion, max_total_expansion-1)
                subbed_styles['back_expansion'] = (
                        max_total_expansion - front_expansion)

        if requirements is None:
            requirements = []
        # We will turn on the `indices_must_match` flag when the
        # replacement index ranges must match the original range of
        # indices and not just match in length:
        indices_must_match = False
        # Stash anything we temporarily pop out of the repl_map.
        repl_map_stash = dict()

        # `var_range_forms` maps variables to the set of equivalent
        # forms of indexing over a range pertinent to getting the
        # replaced entries of this ExprRange.
        # Remove them from the `repl_map` temporarily.
        var_range_forms = dict()
        expanding_occurrences = set()
        parameterized_var_ranges = list(self._parameterized_var_ranges())
        for occurrence in parameterized_var_ranges:
            # `occurrence` may be something like x_k or
            # x_{k,1}, ..., x_{k,n}
            # where `k` is `self.parameter`.
            # If repl_map maps `x` to a set, in this example,
            # then it has an expansion for any of the forms that
            # are contained in the set.
            var = get_param_var(occurrence)
            if var in var_range_forms:
                expanding_occurrences.add(occurrence)
                # Already added this `var` to `var_expansion_forms` and
                # removed it from `repl_map`:
                continue
            repl = repl_map.get(var, None)
            if isinstance(repl, set):
                expanding_occurrences.add(occurrence)
                var_range_forms[var] = repl
                repl_map_stash[var] = repl_map.pop(var)
            elif not indices_must_match:
                # If some variables are expanded but others are not,
                # our replacement index ranges will need to match the
                # original range of indices to be a valid replacement.
                indices_must_match = True
                reason_indices_must_match = var  # temporary assignment
        if len(var_range_forms) > 0:
            expanding_var = next(iter(var_range_forms))
            if indices_must_match:
                # `reason_indices_must_match` was temporarily assigned
                # to a Variable that is not being expanded.  Change it
                # to a proper message now that we have a variable that
                # is being expanded.
                reason_indices_must_match = (
                    "not all of the indexed variables being indexed "
                    "by the ExprRange parameter are being expanded "
                    "(%s is expanded but %s is not)"
                    % (expanding_var, reason_indices_must_match))
        else:
            # Nothing fancy, just basic_replaced of the expression.
            yield self.basic_replaced(
                repl_map, allow_relabeling=allow_relabeling,
                requirements=requirements,
                _subbed_start_index=subbed_start_index,
                _subbed_end_index=subbed_end_index)
            return

        # Need to handle the change in scope within the lambda
        # expression.
        # Note, we should have already gotten requirements
        # when calling self.replaced.
        dummy_reqs = []
        new_params, inner_repl_map, inner_assumptions \
            = self.lambda_map._inner_scope_sub(
                    repl_map, allow_relabeling, dummy_reqs)

        # Sanity check that we didn't introduce new requirements.
        # "_inner_scope_sub" should not introduce anything that
        # wasn't introduced when we called `self.replaced`.
        prev_reqs = set(requirements)
        for req in dummy_reqs:
            assert req in prev_reqs

        assert len(new_params) == 1
        new_param = new_params[0]
        safe_dummy_var = safe_dummy_var(self.body, self.parameter)
        # Restore the repl_map, adding back in what was temporarily
        # popped out.
        repl_map.update(repl_map_stash)

        # If the range parameter is used for anything other than an
        # index of an indexed variable, or not all of the
        # parameterized_var_ranges are expanded, all of the new indices
        # must match the original indices, not just the length.
        excluded_var_ranges = \
            self.body._free_var_ranges(
                exclusions=parameterized_var_ranges)
        if self.parameter in excluded_var_ranges:
            indices_must_match = True
            reason_indices_must_match = (
                "the ExprRange parameter appears outside of IndexedVar "
                "indices")

        # Create `expansions_dict` to map each of the variables being
        # expanded to the expansion that is relevent for this ExprRange.
        expansions_dict = dict()
        #orig_parameters = extract_parameters(self)
        #starts = extract_start_indices(subbed_expr_range)
        #ends = extract_end_indices(subbed_expr_range)
        orig_parameter = self.parameter
        #assert len(starts)==len(ends)==len(orig_parameters)
        for occurrence in expanding_occurrences:
            # We need to create a proper "variable range" with simple
            # parameterized indices.  Any shifts of the indices of
            # the indexed_var_or_range must be absorbed into the
            # starting/ending indices.  For example
            # x_{k+1} with k going from 1 to n should change to
            # x_k with k going from 1+1 to n+1.
            indexed_var = innermost_body(occurrence)
            var_indices = indexed_var.indices
            var = indexed_var.var
            param_index = None

            # Note: We'll make replacements of IndexedVar indices and 
            # start and end range indices of the occurrence, but not the
            # variable itself, before we look up the replacement for the
            # corresponding variable range.
            occurrence_map = dict(repl_map)
            occurrence_map.pop(var)
            occurrence_map.pop(orig_parameter, None)
            subbed_occurrence = occurrence.basic_replaced(
                occurrence_map, allow_relabeling=allow_relabeling, 
                requirements=requirements)
            shift_map = dict()
            for idx in var_indices:
                if orig_parameter in free_vars(idx):
                    # Absorb a shift into the start and end indices
                    # for the repl_map lookup.
                    if param_index is not None:
                        raise ImproperReplacement(
                            self, repl_map,
                            "Failure to expand %s because %s is not a valid "
                            "occurrence with the range parameter %s; multiple "
                            "index occurrences are not allowed."
                            % (self, occurrence, orig_parameter))
                    start_with_absorbed_shift = \
                        idx.basic_replaced(
                                {orig_parameter: subbed_start_index},
                                requirements=requirements)
                    end_with_absorbed_shift = \
                        idx.basic_replaced({orig_parameter: subbed_end_index},
                                              requirements=requirements)
                    start_with_absorbed_shift, end_with_absorbed_shift = (
                            simplified_indices(start_with_absorbed_shift, 
                                               end_with_absorbed_shift,
                                               requirements=requirements))
                    param_index = idx
                    # Since we are absorbing the shift into the 
                    # indices, map idx to a non-shifted parameter:
                    if idx != orig_parameter:
                        shift_map[idx] = orig_parameter
                        # We'll map the original parameter to a safe 
                        # dummy var so we can detect if there are other 
                        # instances of the original parameter with a 
                        # different shift.
                        shift_map[orig_parameter] = safe_dummy_var
            if param_index is None:
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s is not a valid "
                    "occurrence with the range parameter %s; not used as "
                    "an index."
                    % (self, occurrence, orig_parameter))
            if len(shift_map) > 0:
                shifted_occurrence = subbed_occurrence.basic_replaced(
                    shift_map, allow_relabeling=allow_relabeling, 
                    requirements=requirements)
            else:
                shifted_occurrence = subbed_occurrence
            if safe_dummy_var in free_vars(occurrence):
                # There was an instance of the original parameter with a
                # different shift than what we used.  That's not allowed.
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s does not use a "
                    "consistent shift the range parameter %s."
                    % (self, occurrence, orig_parameter))

            _styles = subbed_styles
            var_range = ExprRange(orig_parameter, shifted_occurrence,
                                  true_start_index=start_with_absorbed_shift,
                                  true_end_index=end_with_absorbed_shift,
                                  styles=_styles)

            # Now wrap this "variable range" in an ExprTuple and see
            # if it has a known expansion.
            var_tuple = ExprTuple(var_range)
            var = get_param_var(occurrence)
            if var_tuple not in inner_repl_map:
                def key_var(key): 
                    try:
                        return (get_param_var(key[0]) if
                                isinstance(key, ExprTuple)
                                else get_param_var(key))
                    except (TypeError, ValueError):
                        return None
                var_replacements = \
                    {key: value for key, value in inner_repl_map.items() if
                     key_var(key) == var}
                defaults.var_tuple = var_tuple
                defaults.inner_repl_map = inner_repl_map
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because there is no explicit "
                    "expansion for %s.  The known expansions for "
                    "this variable are %s.\n"
                    "(Note that multiple, equivalent expansion forms "
                    "may be provided to fulfill this requirement "
                    "and ExprTuple.align_ranges may be useful)."
                    % (self, var_tuple, var_replacements))
            repl = inner_repl_map.pop(var_tuple)
            if not isinstance(repl, ExprTuple):
                raise ImproperReplacement(
                    self, repl_map,
                    "Invalid replacement %s for %s; it must be an "
                    "ExprTuple." % (var_tuple, repl))
            
            expansions_dict[subbed_occurrence] = repl.entries

        def raise_failed_expansion_match(first_expansion, expansion,
                                         first_indexed_var_or_range,
                                         indexed_var_or_range):
            raise ImproperReplacement(
                self, repl_map,
                "When expanding IndexedVars within an ExprRange whose "
                "parameter is the index, their expansion ExprRange "
                "indices must all match. %s vs %s do not match as "
                "respective expansions for %s and %s.\n"
                "ExprTuple.align_ranges may be useful.\n"
                "Using multiple, equivalent expansion forms could also "
                "help."
                % (first_expansion, expansion,
                   first_indexed_var_or_range, indexed_var_or_range))

        # Do we need to match the new indices to the original indices?
        if indices_must_match:
            # Yes.  Prepare to do that.
            new_indices = []
            next_index = subbed_start_index

        # Divy up the expansions into aligned entries, each with
        # its own replacement map.  This is in preparation to yield
        # a replaced version of the body for each of these entries.
        # Each entry is either singular (at this level) or an ExprRange
        # (where we will yield a new ExprRange covering a portion of
        # the original ExprRange).  The "alignment" of the entries
        # means that corresponding ExprRange entries must have the
        # same start and end indices (i.e., for different expansions).
        body = self.body
        entry_repl_maps = None
        # This will be a list with only the ExprRange entries and None
        # for non-ExprRange entries.
        first_expansion_entry_ranges = None
        for indexed_var_or_range, expansion in expansions_dict.items():
            parameters = [indexed_var_or_range]
            parameter_vars = [get_param_var(indexed_var_or_range)]
            expansion_iter = iter(expansion)
            # Replacement maps corresponding with this
            # 'indexed_var_or_range' and 'expansion'.
            expansion_repl_maps = []
            expansion_entry_ranges = []
            while True:
                entry_repl_map = dict()
                # Peek ahead; get the next entry without advancing the
                # iter.
                head, expansion_iter = more_itertools.spy(expansion_iter)
                if len(head) == 0:
                    break  # No more entries.
                # See if the next entry is to be a proper ExprRange
                # entry at this level.
                entry = head[0]
                if (isinstance(entry, ExprRange) and
                        is_at_same_nested_range_level(indexed_var_or_range,
                                                      entry.body)):
                    # This is a proper ExprRange entry (at this level).
                    # The replacement map will map
                    # 'indexed_var_or_range' to the body of the entry
                    # with the parameter changed to our 'new_param'.
                    param_repl_map = {entry.parameter: new_param}
                    new_body = entry.body.basic_replaced(param_repl_map)
                    entry_repl_map[indexed_var_or_range.basic_replaced(
                        {orig_parameter:new_param})] = new_body
                    expansion_entry_ranges.append(entry)
                    # Advance the "expansion iter".
                    next(expansion_iter)
                else:
                    # This is not a proper ExprRange entry.  It may
                    # be a simple singular entry, or multiple entries
                    # for a nested ExprRange (which is why we need
                    # to use the 'extract_param_replacements' method).
                    extract_param_replacements(
                        parameters, parameter_vars,
                        expansion_iter, None,
                        requirements, entry_repl_map)
                    # Mark as a non-ExprRange entry by simply appending
                    # None.
                    expansion_entry_ranges.append(None)
                expansion_repl_maps.append(entry_repl_map)
            if first_expansion_entry_ranges is None:
                # This is the first expansion we are processing.
                entry_repl_maps = expansion_repl_maps
                first_expansion_entry_ranges = expansion_entry_ranges
                first_expansion = expansion
                first_indexed_var_or_range = indexed_var_or_range
            else:
                # We have processed other expansions.  Make sure
                # they are consistent w.r.t. ExprRange entries
                # and total number of entries.
                if len(first_expansion_entry_ranges) != len(
                        expansion_entry_ranges):
                    # Failing to have the same number of entries.
                    raise_failed_expansion_match(
                        first_expansion, expansion,
                        first_indexed_var_or_range,
                        indexed_var_or_range)
                for first_expansion_entry, expansion_entry in zip(
                        first_expansion_entry_ranges, expansion_entry_ranges):
                    if (isinstance(expansion_entry, ExprRange)
                            != isinstance(first_expansion_entry, ExprRange)):
                        # Failing to match w.r.t. being an ExprRange
                        # entry or not.
                        raise_failed_expansion_match(
                            first_expansion, expansion,
                            first_indexed_var_or_range,
                            indexed_var_or_range)
                    if isinstance(expansion_entry, ExprRange):
                        if (expansion_entry.true_start_index
                                != first_expansion_entry.true_start_index):
                            # Failed to have the same ExprRange range
                            # (different start).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                        if (expansion_entry.true_end_index !=
                                first_expansion_entry.true_end_index):
                            # Failed to have the same ExprRange range
                            # (different end).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                # Combine the 'expansion_repl_maps' into the
                # 'entry_repl_maps' for all expansions.
                for entry_repl_map, expansion_repl_map in zip(
                        entry_repl_maps, expansion_repl_maps):
                    entry_repl_map.update(expansion_repl_map)

        def update_keys_and_values(orig_repl_map, update):
            '''
            Given an original replacement map, use the 'update' 
            dictionary to make replacements in all of its keys 
            and values.
            '''
            new_repl_map = dict()
            for key, val in orig_repl_map.items():
                key = key.basic_replaced(update)
                if isinstance(val, set):
                    val = {elem.basic_replaced(update) for elem in val}
                else:
                    val = val.basic_replaced(update)
                new_repl_map[key] = val
            orig_repl_map.clear()
            orig_repl_map.update(new_repl_map)

        # Yield a replacement for each of the aligned entry of the
        # expansions.  May be a singular entry or an ExprRange entry
        # representing a portion of the original range.
        for first_expansion_entry_range_or_none, entry_repl_map in zip(
                first_expansion_entry_ranges, entry_repl_maps):
            # Use the 'inner replacement map' updated with the
            # 'entry replacement map' to get the 'full entry replacment
            # map'.
            full_entry_repl_map = dict(inner_repl_map)
            full_entry_repl_map.update(entry_repl_map)
            # Now yield the substitution corresponding to this entry.
            if first_expansion_entry_range_or_none is not None:
                assert isinstance(first_expansion_entry_range_or_none,
                                  ExprRange)
                # For an ExprRange entry, yield a new ExprRange
                # representing a portion of the original range.
                first_expansion_entry = first_expansion_entry_range_or_none
                true_start_index = first_expansion_entry.true_start_index
                true_end_index = first_expansion_entry.true_end_index
                styles = first_expansion_entry.get_styles()
                
                param_repl = new_param
                if (indices_must_match and 
                        quick_simplified_index(true_start_index) 
                        != quick_simplified_index(next_index)):
                    # To make the indices match, we will need to
                    # translate the parameter.  We use
                    # 'quick_simplified' to figure out how to do this
                    # translation, but it will have to be proven to
                    # match later on.
                    shift = subtract(next_index, 
                                     true_start_index).quick_simplified()
                    param_repl = Add(new_param, shift)

                # We'll assume new_param is in the proper interval
                # to make the replacements in the body.
                range_assumption = InSet(new_param,
                                         Interval(true_start_index, 
                                                  true_end_index))

                entry_assumptions = inner_assumptions + (range_assumption,)
                full_entry_repl_map[orig_parameter] = param_repl
                with defaults.temporary() as temp_defaults:
                    temp_defaults.assumptions = entry_assumptions
                    entry = ExprRange(
                            new_param,
                            body.basic_replaced(
                                    full_entry_repl_map,
                                    allow_relabeling=allow_relabeling,
                                    requirements=requirements),
                            true_start_index=true_start_index, 
                            true_end_index=true_end_index, styles=styles)
                yield entry
                if indices_must_match:
                    # We need to know the new_indices match with the
                    # original indices.
                    new_indices.append(
                            ExprRange(new_param, param_repl,
                                      true_start_index=true_start_index, 
                                      true_end_index=true_end_index,
                                      styles=styles))
                    # Move 'next_index' to the end of this range.
                    if param_repl == new_param:
                        next_index = true_end_index
                    else:
                        next_index = param_repl.basic_replaced(
                                        {new_param:true_end_index})
                    # Now add one to 'next_index'.
                    # 'quick_simplified' is okay because we will
                    # have to prove that the indices all match below.
                    next_index = Add(next_index, one).quick_simplified()
            else:
                # For a singular element entry, yield the replaced
                # element.
                if indices_must_match:
                    # The actual range parameter index is needed:
                    update_keys_and_values(full_entry_repl_map, 
                                           {new_param:next_index})
                    full_entry_repl_map[orig_parameter] = next_index
                with defaults.temporary() as temp_defaults:
                    temp_defaults.assumptions = inner_assumptions
                    if isinstance(body, ExprRange):
                        for subentry in body._replaced_entries(
                                full_entry_repl_map, allow_relabeling,
                                requirements):
                            yield subentry
                    else:
                        yield body.basic_replaced(
                                full_entry_repl_map, 
                                allow_relabeling=allow_relabeling,
                                requirements=requirements)

                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(next_index)
                    # 'quick_simplified' is okay because we will
                    # have to prove that the indices all match below.
                    next_index = Add(next_index, one).quick_simplified()

        if indices_must_match:
            # The range parameter appears outside of
            # IndexedVars.  That means that we must match new
            # and original indices precisely, not just their length.
            
            # We also need to make sure that subbed_start_index
            # and subbed_end_index are integers to be consistent
            # with the parameter_condition() we are allowed to assume
            # for the body.
            start_requirement = InSet(subbed_start_index, Integer)
            end_requirement = InSet(subbed_end_index, Integer)
            try:
                requirements.append(start_requirement.prove())
                requirements.append(end_requirement.prove())
            except ProofFailure as e:
                raise ImproperReplacement(
                    self, repl_map,
                    "ExprRange subbed start and end indices, %s and %s, "
                    "must be provably integers: %s"%
                    (subbed_start_index, subbed_end_index, e))
            
            # Now for matching the indices precisely.
            requirement = Equals(
                    ExprTuple(*new_indices),
                    ExprTuple(ExprRange(
                        new_param, new_param,
                        true_start_index=subbed_start_index, 
                        true_end_index=subbed_end_index,
                        styles=subbed_styles)))
            if requirement.lhs == requirement.rhs:
                # No need for the requirement if it is a trivial
                # reflexive identity.
                return
            try:
                requirements.append(requirement.prove())
            except ProofFailure as e:
                raise ImproperReplacement(
                    self, repl_map,
                    "ExprRange indices failed to match expansion "
                    "which is necessary because %s: %s."
                    % (reason_indices_must_match, e))

    def parameters(self):
        '''
        Return a list of parameters, one for each nested
        ExprRange.
        '''
        return extract_parameters(self)

    def innermost_body(self):
        '''
        Return the innermost body of a nested ExprRange.
        '''
        return innermost_body(self)

    def start_indices(self):
        '''
        Return a list of starting indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has start indices (m, i_m).
        '''
        return extract_start_indices(self)

    def end_indices(self):
        '''
        Return a list of ending indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has end indices (n, j_n).
        '''
        return extract_end_indices(self)

    def mapped_range(self, body_map_fn):
        '''
        Generate an ExprRange with the same external structure
        as this range but converts the innermost by applying the
        'body_map_fn' to it.
        '''
        inner_body = self.innermost_body(self)
        new_inner_body = body_map_fn(inner_body)
        parameters = extract_parameters(self)
        start_indices = extract_start_indices(self)
        end_indices = extract_end_indices(self)
        return nested_range(parameters, new_inner_body, start_indices,
                            end_indices)

    @equality_prover("partitioned", "split")
    def partition(self, before_split_idx, *, 
                  force_to_treat_as_increasing=False,
                  **defaults_config):
        '''
        Return the equation between this range within an ExprTuple
        and a split version in the following manner:
            (f(self.true_start_index), ..., f(self.true_end_index)) =
            (f(self.true_start_index), ..., f(before_split_index),
             f(before_split_index+1), ..., f(self.true_end_index))
        where f represents the self.lambda_map.
        '''
        from proveit import f, i, j, k
        from proveit.logic import Equals
        from proveit.numbers import (Add, one, subtract, 
                                     quick_simplified_index)
        from proveit.core_expr_types.tuples import (
            range_extension_def)
        from proveit.core_expr_types.tuples import (
            partition_front, partition_back, partition)

        lambda_map = self.lambda_map
        default_order = 'increasing'
        if force_to_treat_as_increasing:
            decreasing = False
        elif self.get_style('order', default_order) == 'decreasing':
            from proveit.numbers import Neg
            before_split_idx = Neg(before_split_idx)
            decreasing = True
        else:
            decreasing = False
        start_index, end_index = self.true_start_index, self.true_end_index
        if end_index == Add(before_split_idx, one):
            # special case which uses the axiom:
            judgment = range_extension_def.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx})
        elif before_split_idx == self.true_start_index:
            # special case when peeling off the front
            judgment = partition_front.instantiate(
                {f: lambda_map, i: self.true_start_index, j: self.true_end_index})
        elif (quick_simplified_index(before_split_idx) == 
                  quick_simplified_index(subtract(end_index, one))):
            # special case when peeling off the back
            judgment = partition_back.instantiate(
                {f: lambda_map, i: start_index, j: end_index})
        else:
            judgment = partition.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx,
                 k: end_index})

        if decreasing:
            judgment = judgment.inner_expr().lhs[0].with_decreasing_order()
            for i, item in enumerate(judgment.rhs):
                if isinstance(item, ExprRange):
                    judgment = judgment.inner_expr().rhs[i].with_decreasing_order()
        return judgment
    
    @prover
    def range_fn_transformation(self, new_lambda_map, **defaults_config):
        '''
        Return the equation between this range within an ExprTuple and
        one with a new lambda map.
        
        For example:
            (f(i), f(i+1), ..., f(j)) =  (g(i), g(i+1), ..., g(j))
        as long as f(k)) = g(k) for all k in [i .. j].
        '''
        from proveit import i, j, k, f, g
        from proveit.core_expr_types.tuples import range_fn_transformation
        return range_fn_transformation.instantiate(
                {i:self.true_start_index, j:self.true_end_index, f:self.lambda_map,
                 g:new_lambda_map, k:new_lambda_map.parameter},
                 preserve_expr=ExprTuple(self)).derive_consequent()

    @equality_prover("shifted", "shift")
    def shift_equivalence(self, *, old_shift=None, new_start=None,
                          new_end=None, new_shift=None,
                          force_to_treat_as_increasing=False,
                          **defaults_config):
        '''
        Return the equation between this range within an ExprTuple
        and a shifted version in the following manner:
            (f(self.true_start_index+old_shift), ..., f(self.true_end_index+old_shift)) =
            (f(new_start+new_shift), ..., f(new_start+new_shift))
        where f is adapted from self.lambda_map according to 'old_shift'.
        If any of the 'new' parameters are unspecified, we attempt
        to deduce them from the other parameters.
        '''
        from proveit import a, b, f, i, j, k, l
        from proveit.numbers import Add, Neg, subtract
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.core_expr_types.tuples import (
            shift_equivalence, negated_shift_equivalence, negated_shift_equivalence_both, shift_equivalence_both)

        default_order = 'increasing'
        if force_to_treat_as_increasing:
            decreasing = False
        elif self.get_style('order', default_order) == 'decreasing':
            from proveit.numbers import Neg
            decreasing = True
            print("we are decreasing")
        else:
            decreasing = False

        if old_shift is None:
            _f = self.lambda_map
        else:
            if decreasing:
                old_shift = Neg(old_shift)
            old_shifted_param = Add(self.parameter, old_shift)
            safe_var = safe_dummy_var(self.body)
            shifted_body = self.body.basic_replaced({old_shifted_param: safe_var})
            if self.parameter in free_vars(shifted_body):
                raise ValueError("The given 'old_shift' of %s does apply "
                                 "to %s" % (old_shift, self.lambda_map))
            _f = Lambda(self.parameter,
                        shifted_body.basic_replaced({safe_var: self.parameter}))

        _i, _j = self.true_start_index, self.true_end_index

        if new_shift is not None:
            if decreasing:
                new_shift = Neg(new_shift)
            net_shift = new_shift
            if old_shift is not None:
                net_shift = subtract(new_shift, old_shift).simplified()
            if new_start is None:
                # new start = _i - new_shift
                new_start = subtract(_i, net_shift).simplified()
            elif decreasing:
                new_start = Neg(new_start)
            if new_end is None:
                # new_end = _j - new_shift
                new_end = subtract(_j, net_shift).simplified()
            elif decreasing:
                new_end = Neg(new_end)
        elif new_start is None:
            # new_start = new_end + i - j
            new_end = Add(new_start, _i, Neg(_j)).simplified()
        elif new_end is None:
            # new_end = new_start + j - i
            if decreasing:
                new_start = Neg(new_start)
            new_end = Add(new_start, _j, Neg(_i)).simplified()

        _k, _l = new_start, new_end

        if new_shift is None:
            # Compute the new shift based upon the other parameters.
            if old_shift is None:
                new_shift = subtract(_i, _k).simplified()
            else:
                new_shift = Add(_i, old_shift, Neg(_k)).simplified()

        if old_shift is None:
            if decreasing:
                print("correct!")
                judgment = negated_shift_equivalence.instantiate(
                    {f: _f, a: new_shift, i: _i.operand, j: _j.operand, k: _k, l: _l})
            else:
                judgment = shift_equivalence.instantiate(
                    {f: _f, a: new_shift, i: _i, j: _j, k: _k, l: _l})
        else:
            if decreasing:
                judgment = negated_shift_equivalence_both.instantiate(
                    {f: _f, a: old_shift, b: new_shift, i: _i.operand, j: _j.operand, k: _k, l: _l})
            else:
                judgment = shift_equivalence_both.instantiate(
                    {f: _f, a: old_shift, b: new_shift, i: _i, j: _j, k: _k, l: _l})

        # if decreasing:
        #     lhs_done = judgment.inner_expr().lhs[0].with_decreasing_order()
        #     return lhs_done.inner_expr().rhs[0].with_decreasing_order()
        # else:
        return judgment

    """
    def _var_index_shifts_in_ranges(self, var, shifts):
        '''
        Given a 'var' (e.g., 'x'), pass back, via the set 'shifts',
        all of the constant indexed shifts to the ExprRange parameter
        within ExprRanges (e.g., 'x_{1+1}, ..., x_{n+1}' would have
        presumably have a shift of 1).
        '''
        self.body._indexed_var_shifts(var, self.parameter, shifts)
        Expression._var_index_shifts_in_ranges(self, var, shifts)
    """


def simplified_index(index, *, requirements=None):
    return list(simplified_indices(index, requirements=requirements))[0]

def simplified_indices(*indices, requirements=None):
    from proveit.logic import Equals
    from proveit.numbers import Add, quick_simplified_index, is_numeric_int
    for index in indices:
        simplified_index = quick_simplified_index(index)
        if requirements is not None:
            requirement = Equals(index, simplified_index)
            if requirement.lhs != requirement.rhs:
                if requirement.proven():
                    # Already proven, so record the requirement and move on.
                    requirements.append(requirement.prove())
                    yield simplified_index
                    continue
                with Add.temporary_simplification_directives() as directives:
                    # Move literal integers to the end via the
                    # 'order_key_fn' simplification directive for Add.
                    directives.order_key_fn = lambda term : (
                        1 if is_numeric_int(term) else 0)
                    index.simplified() 
                try:
                    requirements.append(requirement.prove())
                except ProofFailure as e:
                    raise ProofFailure(
                            requirement, defaults.assumptions,
                            "Failed to prove the %s as an index "
                            "simplification in an ExprRange expansion: %s"
                            %(requirement, e))
        yield simplified_index

class InstanceContext(object):
    '''
    Context manager for inspecting a particular indexed instance of
    an ExprRange.  The context uses temporary assumptions that
    distinguish the index from the indices of other instances for
    formatting/inspection purposes (useful for case simplifications
    of nested ExprRanges that have 'case_simplify'='True' style).
    '''
    def __init__(self, instance, default_temp_setter):
        self.instance = instance
        self.default_temp_setter = default_temp_setter
    
    def __enter__(self):
        return self
    
    def __exit__(self, type, value, traceback):
        self.default_temp_setter.__exit__(type, value, traceback)


def _has_expansion(var_form, repl_map):
    '''
    Return True if and only if the given IndexedVar has
    an expansion in the given replacement map.
    '''
    from proveit._core_.expression.lambda_expr.lambda_expr import \
        get_param_var
    var_repl = repl_map.get(get_param_var(var_form), None)
    # When being expanded, a set of equivalent tuples of
    # indexed variables is used as the direct variable
    # replacement (e.g. x : {(x_1, ..., x_{n+1}),
    #                        (x_1, ..., x_n, x_{n+1})}).
    return isinstance(var_repl, set)


def extract_start_indices(expr_range):
    '''
    Return a list of starting indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has start indices (m, i_m).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        start_index = expr.true_start_index
        subbed_index = start_index.basic_replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_end_indices(expr_range):
    '''
    Return a list of ending indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has end indices (n, j_n).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        end_index = expr.true_end_index
        subbed_index = end_index.basic_replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_parameters(expr_range):
    '''
    Return a list of parameters, one for each nested
    ExprRange.
    '''
    parameters = []
    expr = expr_range
    while isinstance(expr, ExprRange):
        parameters.append(expr.parameter)
        expr = expr.body
    return parameters


def innermost_body(expr_range):
    '''
    Return the innermost body of a nested ExprRange.
    '''
    expr = expr_range
    while isinstance(expr, ExprRange):
        expr = expr.body
    return expr


def is_at_same_nested_range_level(expr1, expr2):
    '''
    Return True iff 'expr1' and 'expr2' are either both
    ExprRanges, or nested ExprRanges at the same number of levels.
    '''
    while True:
        if isinstance(expr1, ExprRange) != isinstance(expr2, ExprRange):
            # Levels don't match.
            return False
        if not isinstance(expr1, ExprRange):
            # Made it to the end without encountering a mismatch.
            return True
        # Go another level deeper.
        expr1 = expr1.body
        expr2 = expr2.body


def nested_range(parameters, body, start_indices, end_indices):
    if len(parameters) > 1:
        # multiple levels
        inner_body = nested_range(parameters[1:], body,
                                  start_indices[1:], end_indices[1:])
    else:
        # single level
        inner_body = body
    if start_indices[0] == end_indices[0]:
        # When the start and end indices are the same, reduce it
        # to a single instance.
        return inner_body.basic_replaced({parameters[0]: start_indices[0]})
    return ExprRange(parameters[0], inner_body,
                     start_indices[0], end_indices[0])

def var_range(var, start_index_or_indices, end_index_or_indices):
    from proveit import (safe_dummy_vars, composite_expression,
                         IndexedVar)
    start_indices = composite_expression(start_index_or_indices)
    end_indices = composite_expression(end_index_or_indices)
    parameters = safe_dummy_vars(start_indices.num_entries(), var, 
                                 start_indices, end_indices)
    return nested_range(parameters, IndexedVar(var, parameters),
                        start_indices, end_indices)


class RangeInstanceError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg
