import more_itertools

from proveit._core_.expression.expr import (Expression, MakeNotImplemented,
                                            ImproperReplacement,
                                            free_vars)
from proveit._core_.expression.style_options import StyleOptions
from proveit._core_.expression.lambda_expr.lambda_expr import Lambda
from proveit._core_.expression.composite import singular_expression, ExprTuple
from proveit._core_.expression.conditional import Conditional
from proveit._core_.proof import ProofFailure, UnsatisfiedPrerequisites
from proveit._core_.defaults import defaults, USE_DEFAULTS
from proveit.decorators import prover, equality_prover

class ExprRange(Expression):
    '''
    An ExprRange expression represents a range of "element" expressions
    within a containing ExprTuple.  It represents this as a Lambda to
    map each valid index value to a corresponding element, along with a
    start and end index value.  The represented element sequence
    corresponds to index values going from the start to the end in
    increments of 1, ranging over index values.

    For example,
    1/i + ... + 1/j
    is internall represented by an Add operation with the following as
    its "operands":
    (1/i, ..., 1/j).
    These "operands" are represented by an ExprTuple with a single
    "entry" which is an ExprRange whose `lambda_map` is "k |-> 1/k",
    `start_index` is "i", and `end_index` is "j".  An ExprTuple "entry"
    may generally either be a singuler element or an ExprRange that
    represents multiple elements.
    '''

    def __init__(self, parameter, body, start_index, end_index, *,
                 parameterization=None, lambda_map=None,
                 styles=None):
        '''
        Create an ExprRange that represents a range of expressions
        to be embedded within an ExprTuple.  Each element of the
        range is generated by mapping the parameter according to the
        body with the parameter ranging from the start index to the
        end index.
        A Lambda expression will be created as its first sub-expression.
        The start and end indices with be the second and third
        sub-expressions.

        The 'parameterization' sets the style for formatting the
        ExprRange.  The default is "implicit" for LaTeX formatting
        but "explicit" for string formatting.  Since string formatting
        is most often used for error messages, it is useful to have
        the full "explicit" version.

        The lambda_map may be used instead of supplying the parameter
        and body, in which case the 'parameter' and 'body' arguments
        must both be None.
        '''
        from proveit import Variable
        if lambda_map is not None:
            # Use the provided 'lambda_map' instead of creating one.
            lambda_map = lambda_map
            if (parameter, body) != (None, None):
                raise ValueError("'parameter' and 'body' arguments of the "
                                 "ExprRange constructor should be None if "
                                 "lambda_map is provided.")
            parameter = lambda_map.parameter
        else:
            if not isinstance(parameter, Variable):
                raise TypeError("The 'parameter' of an ExprRange must be "
                                "a Variable.")
            lambda_map = Lambda(parameter, body)
        if parameterization not in (None, 'implicit', 'explicit'):
            raise ValueError("'parameterization' must be 'implicit', "
                             "'explicit', or None; not %s" % parameterization)
        if parameterization is not None:
            if styles is None: styles = dict()
            styles['parameterization'] = parameterization

        Expression.__init__(self, ['ExprRange'],
                            [lambda_map, start_index, end_index],
                            styles=styles)
        self.start_index = singular_expression(start_index)
        self.end_index = singular_expression(end_index)
        if self.start_index == self.end_index:
            raise ValueError(
                    "Do not create an ExprRange with the same start and "
                    "end index since it reduces to a single instance.  "
                    "Note that nested_range/var_range automatically "
                    "perform this reduction.")
        self.lambda_map = lambda_map
        self.parameter = self.lambda_map.parameter
        self.body = self.lambda_map.body
        self.is_parameter_independent = (
            self.parameter not in free_vars(self.body))

    @classmethod
    def _make(sub_class, core_info, sub_expressions, *, styles):
        if sub_class != ExprRange:
            MakeNotImplemented(sub_class)
        if len(core_info) != 1 or core_info[0] != 'ExprRange':
            raise ValueError("Expecting ExprRange core_info to contain "
                             "exactly one item: 'ExprRange'")
        lambda_map, start_index, end_index = sub_expressions
        return ExprRange(None, None, start_index, end_index,
                         styles=styles, lambda_map=lambda_map)

    @staticmethod
    def _proper_sub_expr_replacements(orig_sub_exprs, subbed_sub_exprs):
        '''
        Given original sub-expressions and "subbed" (substituted) 
        sub-expressions for and ExprRange, return new subbed 
        sub-expressions that are revised appropriately if necessary to 
        nsure that the start and end indices are different, and the 
        start is the original version.
        '''
        start_index, end_index = subbed_sub_exprs[1:]
        if start_index == end_index:
            # Use the simplification for the start index,
            # but something equal to it but not the same expression
            # for the end index.
            if orig_sub_exprs[2] == start_index:
                assert orig_sub_exprs[1] != start_index, (
                    "start and end indices should not be the same")
                return (subbed_sub_exprs[0], subbed_sub_exprs[1],
                        orig_sub_exprs[1])
            else:
                return (subbed_sub_exprs[0], subbed_sub_exprs[1],
                        orig_sub_exprs[2])
                
        return subbed_sub_exprs

    def basic_replaced(self, repl_map, *, 
                       allow_relabeling=False, requirements=None,
                       _subbed_start_index=None,
                       _subbed_end_index=None):
        '''
        ExprRange.basic_replaced handles the case of reducing to
        a singular instance when start and end indices are the same.
        '''
        if len(repl_map) > 0 and (self in repl_map):
            replaced = repl_map[self]
        else:
            if _subbed_start_index is None:
                _subbed_start_index, _subbed_end_index = (
                        sub_expr.basic_replaced(
                            repl_map, allow_relabeling=allow_relabeling,
                            requirements=requirements)
                    for sub_expr in (self.start_index, self.end_index))
            else:
                assert _subbed_end_index is not None
            if _subbed_start_index == _subbed_end_index:
                # Reduced to a single instance since the start and
                # end indices are the same.
                return self._singular_reduced(
                        repl_map, _subbed_index=_subbed_start_index,
                       allow_relabeling=allow_relabeling, 
                       requirements=requirements)
            sub_exprs = self._sub_expressions
            assert sub_exprs == (self.lambda_map, self.start_index,
                                 self.end_index)
            # Complete the subbed_sub_exprs
            subbed_sub_exprs = (
                    self.lambda_map.basic_replaced(
                            repl_map, allow_relabeling=allow_relabeling,
                            requirements=requirements),
                    _subbed_start_index, _subbed_end_index)
            if all(subbed_sub._style_id == sub._style_id for
                   subbed_sub, sub in zip(subbed_sub_exprs, sub_exprs)):
                # Nothing change, so don't remake anything.
                return self
            replaced = self.__class__._checked_make(
                self._core_info, subbed_sub_exprs,
                style_preferences=self._style_data.styles)
        return replaced
        
    def _singular_reduced(self, repl_map, *, _subbed_index,
                       allow_relabeling=False, requirements=None):
        '''
        Return a basic replaced version where there is a singular
        reduction to the given _subbed_index.
        '''
        singular_instance = self.lambda_map.body.basic_replaced(
                            {self.parameter:_subbed_index},
                            requirements=requirements)
        return singular_instance.basic_replaced(
                repl_map, allow_relabeling=allow_relabeling,
                requirements=requirements)            

    def literal_int_extent(self):
        '''
        If the start and end indices of this ExprRange are literal integers,
        return the literal number of elements of the ExprRange.  For the
        case of nested ExprRange's, all of the start and end indices must
        be integers and the result will be the multiplied extent.  For
        example:
            a_{1,1}, ..., a_{1,3}, ......, a_{4,1}, ..., a_{4,3}
        has a literal_int_extent of 12.
        '''
        from proveit.numbers import is_literal_int
        if (is_literal_int(self.start_index) and is_literal_int(self.end_index)):
            toplevel_extent = (
                self.end_index.as_int() -
                self.start_index.as_int() +
                1)
            if isinstance(self.body, ExprRange):
                return toplevel_extent * self.body.literal_int_extent()
            else:
                return toplevel_extent
        raise ValueError(
            "literal_int_extent may only be used on an ExprRange  "
            "with start and end indices that are literal integers")

    def remake_arguments(self):
        '''
        Yield the argument values or (name, value) pairs
        that could be used to recreate the ExprRange.
        '''
        yield self.lambda_map.parameter
        yield self.lambda_map.body
        yield self.start_index
        yield self.end_index

    def remake_with_style_calls(self):
        '''
        In order to reconstruct this Expression to have the same styles,
        what "with..." method calls are most appropriate?  Return a
        tuple of strings with the calls to make.  The default for the
        Operation class is to include appropriate 'with_wrapping_at'
        and 'with_justification' calls.
        '''
        call_strs = []
        parameterization = self.get_style('parameterization', 'default')
        if parameterization != 'default':
            if parameterization == 'explicit':
                call_strs.append('with_explicit_parameterization()')
            if parameterization == 'implicit':
                call_strs.append('with_implicit_parameterization()')
        front_expansion = self.get_front_expansion()
        if front_expansion != '2':
            call_strs.append('with_front_expansion(%d)'%int(front_expansion))
        back_expansion = self.get_back_expansion()
        if back_expansion != '1':
            call_strs.append('with_back_expansion(%d)'%int(back_expansion))
        simplify = self.get_style('simplify', 'False')
        if simplify != 'False':
            if simplify == 'True':
                call_strs.append('with_simplification()')
        return call_strs

    def style_options(self):
        options = StyleOptions(self)
        options.add_option(
            name='parameterization',
            description=(
                    "'implicit' (default for LaTeX formatting) hides "
                    "the parameter the ExprRange so the parameterization "
                    "may be ambiguous (e.g., x_{1+1}, ..., x_{n+1}); "
                    "'explicit' (default for string formatting) reveals "
                    "the parameterization "
                    "(e.g. x_{1+1}, ..x_{k+1}.., x_{n+1})."),
            default=None,
            related_methods=('with_explicit_parameterization',
                             'with_implicit_parameterization',
                             'with_default_parameterization_style'))

        options.add_option(
            name='front_expansion',
            description=(
                "The number of instances to display at the front of the "
                "range (e.g., before the ellipsis). Default is 2."),
            default=str(2),
            related_methods=('with_front_expansion', 'get_front_expansion'))
        options.add_option(
            name='back_expansion',
            description=(
                "The number of instances to display at the back of the "
                "range (e.g., after the ellipsis). Default is 1."),
            default=str(1),
            related_methods=('with_back_expansion', 'get_back_expansion'))
        options.add_option(
                name='wrap_positions',
                description=("position(s) at which wrapping is to occur; "
                             "'n' is after the nth comma."),
                default = '()',
                related_methods = ('with_wrapping_at',))
        options.add_option(
            name='case_simplify',
            description=(
                    "If 'True', simplify formatted instances "
                    "that are ConditionalSets under proper index "
                    "assumptions"),
            default='False',
            related_methods=('with_case_simplification',)
        )
        return options

    def with_explicit_parameterization(self):
        '''
        The 'parameterization':'explicit' style shows the
        parameterization of the ExprRange explicitly.  For example,
        x_{1+1}, ..x_{k+1}.., x_{n+1}).
        '''
        return self.with_styles(parameterization='explicit')

    def with_implicit_parameterization(self):
        '''
        The 'parameterization':'implicit' style does not show the
        parameterization of the ExprRange explicitly and such that the
        parameterization may be ambiguous but is more compact.
        For example, x_{1+1}, ..., x_{n+1} could be
        x_{1+1}, ..x_{k+1}.., x_{n+1}
        or could be
        x_{1+1}, ..x_{k}.., x_{n+1}.
        '''
        return self.with_styles(parameterization='implicit')

    def with_default_parameterization_style(self):
        '''
        The default is to use an 'implicit' parameterization for
        string formatting (see 'with_implicit_parameterization') and
        and 'explicit' parameterization for LaTeX formatting
        (see 'with_explicit_parameterization').
        '''
        return self.without_style('parameterization')
    
    def with_case_simplification(self):
        '''
        Simplify the formatted instances for the style.
        '''

        return self.with_styles(case_simplify='True')

    def with_front_expansion(self, num):
        '''
        Set the number of instances to display at the front of the 
        range (e.g., before the ellipsis).
        '''
        if not isinstance(num, int) or num < 1:
            print("front_expansion must be an integer of at least 1")
        return self.with_styles(front_expansion=str(num))

    def with_back_expansion(self, num):
        '''
        Set the number of instances to display at the back of the 
        range (e.g., after the ellipsis).
        '''
        if not isinstance(num, int) or num <= 1:
            print("back_expansion must be an integer of at least 1")
        return self.with_styles(back_expansion=str(num))

    def with_wrapping_at(self, *wrap_positions):
        return self.with_styles(
            wrap_positions='(' +
            ' '.join(
                str(pos) for pos in wrap_positions) +
            ')')

    def get_front_expansion(self):
        '''
        Get the number of instances to display at the front of the 
        range (e.g., before the ellipsis).
        '''
        return int(self.get_style('front_expansion'))

    def get_back_expansion(self):
        '''
        Get the number of instances to display at the back of the 
        range (e.g., after the ellipsis).
        '''
        return int(self.get_style('back_expansion'))

    def wrap_positions(self):
        '''
        Return a list of wrap positions according to the current style 
        setting.  Position 'n' is after the nth comma.
        '''
        return [int(pos_str) for pos_str in self.get_style(
            'wrap_positions', '').strip('()').split(' ') if pos_str != '']

    def body_replaced(self, index):
        '''
        Return the body replaced according the the expression map.
        First attempt to do this with auto-simplification.  If that
        fails, do it without auto-simplification.
        '''
        from proveit import ConditionalSet
        from proveit.logic import Not, Equals, NotEquals, InSet
        from proveit.numbers import Less, num, Add, zero, Interval
        from proveit.numbers.addition.add import split_int_shift
        expr_map = {self.lambda_map.parameter: index}
        # For purposes of displaying/exploring, we will assume
        # that the expanded indices are in a proper order and that
        # the front expansion does not overlap with the back expansion.
        with defaults.temporary() as temp_defaults:
            temp_defaults.automation = False
            temp_defaults.preserve_all = True
            assumptions = []
            index = Add(index, zero).quick_simplified()
            index_base, index_shift = split_int_shift(index)
            start_base, start_shift = split_int_shift(self.start_index)
            end_base, end_shift = split_int_shift(self.end_index)
            if index_base not in (start_base, end_base):
                raise ValueError(
                        "'index' %s must be a literal integer shift "
                        "from %s or %s"%(index, start_base, end_base))
            for base, other_shift_range in (
                    (start_base, range(
                            start_shift, 
                            start_shift+self.get_front_expansion())),
                    (end_base, range(
                            end_shift-self.get_back_expansion()+1, 
                            end_shift+1))):
                for other_shift in other_shift_range:
                    other_index = Add(base, 
                                      num(other_shift)).quick_simplified()
                    if index_base == base:
                        if other_shift == index_shift:
                            assert index == other_index
                            # Trivial, but include it anyways so
                            # we won't need any automation:
                            assumptions.append(Equals(index, other_index))
                        else:
                            assumptions.append(NotEquals(index, other_index))
                            if other_shift < index_shift:
                                assumptions.append(Less(other_index, index))
                            else:
                                assumptions.append(Less(index, other_index))                            
                    else:
                        if base == start_base:
                            assumptions.append(Less(other_index, index))
                        else:
                            assumptions.append(Less(index, other_index))
                        assumptions.append(NotEquals(index, other_index))
            # To avoid automation, we need to include many variants.
            net_assumptions = list(defaults.assumptions)
            for assumption in assumptions:
                net_assumptions.append(assumption)
                lhs, rhs = assumption.operands
                if isinstance(assumption, Equals):
                    net_assumptions.append(Not(NotEquals(lhs, rhs)))
                    if lhs != rhs:
                        net_assumptions.append(Equals(rhs, lhs))
                        net_assumptions.append(Not(NotEquals(rhs, lhs)))
                if isinstance(assumption, NotEquals):
                    net_assumptions.append(Not(Equals(lhs, rhs)))
                    if lhs != rhs:
                        net_assumptions.append(NotEquals(rhs, lhs))
                        net_assumptions.append(Not(Equals(rhs, lhs)))
                if isinstance(assumption, Less):
                    net_assumptions.append(Not(Less(rhs, lhs)))
            temp_defaults.assumptions = net_assumptions
            instance = self.body.basic_replaced(expr_map)
            if self.get_style('case_simplify') == 'True':
                if isinstance(instance, ConditionalSet):
                    # Effect the simplification of the conditional set
                    # if possible without automation and with no proof
                    # (display/inspection purposes only).
                    new_conditionals = []
                    for conditional_entry in instance.conditionals:
                        conditional = conditional_entry
                        extra_assumptions = []
                        while isinstance(conditional, ExprRange):
                            # An range of conditionals: add the 
                            # assumption that the range parameter is
                            # within the Interval and dig into the body.
                            extra_assumptions.append(
                                    InSet(conditional.parameter,
                                          Interval(conditional.start_index,
                                                   conditional.end_index)))
                            conditional = conditional.body
                        if isinstance(conditional, Conditional):
                            # Check the condition of the conditional.
                            # If proven, use just the value.
                            # If disproven, skip this entry.
                            condition = conditional.condition
                            if len(extra_assumptions) > 0:
                                with defaults.temporary() as tmp_defaults2:
                                    tmp_defaults2.assumptions = (
                                            defaults.assumptions +
                                            extra_assumptions)
                                    proven_condition = condition.proven()
                                    dispoven_condition = condition.disproven()
                            else:
                                proven_condition = condition.proven()
                                dispoven_condition = condition.disproven()
                            if proven_condition:
                                new_conditionals.append(conditional.value)
                                continue
                            elif dispoven_condition:
                                # Skip over this conditional with the
                                # false condition.
                                continue
                        new_conditionals.append(conditional_entry)
                    if len(new_conditionals) == 1:
                        # All but one condition is disproven.  If the
                        # remaining condition is proven, this will be
                        # the value of that conditional.
                        instance = new_conditionals[0]
                    elif tuple(new_conditionals) != instance.conditionals:
                        # Create the simplified ConditionalSet.
                        instance = ConditionalSet(*new_conditionals)
        if isinstance(instance, Add):
            return instance.quick_simplified()
        return instance

    def first(self):
        '''
        Return the first instance of the range
        (and store for future use).
        '''
        """
        if not hasattr(self, '_first') or self.get_styles() != self._first_style:
            expr_map = {self.lambda_map.parameter: self.start_index}
            self._first = self._body_replaced(expr_map)
            self._first_style = self.get_styles()
            #self.get_range_expansion()
            #self.last()
        return self._first
        """
        return self.body_replaced(self.start_index)
        

    def last(self):
        '''
        Return the last instance of the range
        (and store for future use).
        '''
        """
        if not hasattr(self, '_last') or self.get_styles() != self._last_style:
            expr_map = {self.lambda_map.parameter: self.end_index}
            self._last = self._body_replaced(expr_map)
            self._last_style = self.get_styles()
            #self.get_range_expansion()
            #self.first()
        return self._last
        """
        return self.body_replaced(self.end_index)

    def format_length(self):
        '''
        The length of the ExprRange when it is formatted according to the expansion.
        '''
        return self.get_front_expansion() + 1 + self.get_back_expansion()

    def string(self, **kwargs):
        return self.formatted('string', **kwargs)

    def latex(self, **kwargs):
        return self.formatted('latex', **kwargs)

    def nested_range_depth(self):
        '''
        Return the depth of nested ranges.  For example, if this
        is a simple range with no nesting, return 1.
        If this is a range of simple ranges, return 2.
        If this is a range of ranges of simple ranges, return 3.
        '''
        depth = 1
        expr = self.body
        while isinstance(expr, ExprRange):
            depth += 1
            expr = expr.body
        return depth

    def _use_explicit_parameterization(self, format_type):
        '''
        Return True iff explicit parameterization should be used
        for the given format type given the 'style' settings.
        The default using 'explicit' for 'string' format and 'implicit'
        for 'latex' format.
        '''
        default_style = ("explicit" if format_type == 'string' else 'implicit')
        if (self.get_style("parameterization", default_style) == "explicit"):
            return True
        return False

    def _formatted_entries(self, format_type, *,
                           operator_or_operators=',',
                           implicit_first_operator=False, **kwargs):
        format_cell_entries = []
        self._append_format_cell_entries(format_cell_entries)
        if (isinstance(operator_or_operators, ExprRange) and
                operator_or_operators.is_parameter_independent):
            operator_or_operators = operator_or_operators.body
        if isinstance(operator_or_operators, ExprRange):
            operator_or_operators = (
                    operator_or_operators.with_mimicked_style(self))
            formatted_operator_entries = []
            operator_or_operators._append_format_cell_entries(
                    formatted_operator_entries)
            # Grab just the expression, not the "role".
            formatted_operators = [(expr.formatted(format_type)+' '
                                    if (not isinstance(expr, ExprRange))
                                       else '') for
                                   expr, role in formatted_operator_entries]
        elif isinstance(operator_or_operators, Expression):
            _operator = operator_or_operators.formatted(format_type)
            formatted_operators = [_operator+' ']*len(format_cell_entries)
        else:
            formatted_operators = [operator_or_operators]*len(
                    format_cell_entries)
        if implicit_first_operator:
            formatted_operators[0] = ''
        formatted_entries = []
        for (expr, role), formatted_operator in zip(format_cell_entries, 
                                                    formatted_operators):
            if isinstance(expr, ExprRange):
                nested_range_depth = expr.nested_range_depth()
            else:
                nested_range_depth = 1
            if len(formatted_entries) > 0:
                if formatted_operator != ',':
                    formatted_operator = ' ' + formatted_operator
                formatted_operator = formatted_operator + ' '                
            if role == 'implicit':
                ellipsis = ('\ldots' if format_type == 'latex'
                            else '...')
                ellipsis = ellipsis * nested_range_depth
                formatted_entries.append([formatted_operator, ellipsis])
            else:
                ellipsis = '..' * nested_range_depth
                if role == 'param_independent':
                    formatted_entries.append(
                            [formatted_operator,
                             ellipsis + expr.formatted_repeats(format_type) 
                             + ellipsis])
                elif role == 'explicit':
                    formatted_body = expr.body.formatted(format_type)    
                    formatted_entries.append(
                            [formatted_operator,
                             ellipsis + formatted_body + ellipsis])
                else:
                    formatted_expr = expr.formatted(format_type)
                    formatted_entries.append([formatted_operator,
                                              formatted_expr])
        return formatted_entries

    def formatted(self, format_type, **kwargs):
        wrap_positions = self.wrap_positions()
        justification = 'left'
        return ExprTuple(self).formatted(format_type,
                 fence=False, sub_fence=True,
                 operator_or_operators=',',
                 implicit_first_operator=True,
                 wrap_positions=wrap_positions,
                 justification=justification)

    def get_instance(self, index, assumptions=USE_DEFAULTS,
                     requirements=None, equality_repl_requirements=None):
        '''
        Return the range instance with the given Lambda map
        index as an Expression, using the given assumptions as
        needed to interpret the index expression.  Required
        truths, proven under the given assumptions, that
        were used to make this interpretation will be
        appended to the given 'requirements' (if provided).
        '''
        from proveit.numbers import LessEq

        if requirements is None:
            # requirements won't be passed back in this case
            requirements = []

        # first make sure that the indices are in the range
        start_index, end_index = self.start_index, self.end_index
        for first, second in ((start_index, index), (index, end_index)):
            relation = None
            try:
                relation = LessEq.sort([first, second], reorder=False,
                                       assumptions=assumptions)
            except BaseException:
                raise RangeInstanceError(
                    "Indices not provably within the range "
                    "range: %s <= %s" % (first, second))
            requirements.append(relation)

        # map to the desired instance
        return self.lambda_map.apply(
            index, assumptions=assumptions, requirements=requirements,
            equality_repl_requirements=equality_repl_requirements)

    def num_elements(self, proven=True, **defaults_config):
        '''
        Return the number of elements represented by this ExprRange.
        This includes the extent of all contained ranges.
        If proven==True, a proof is constructed in the process.
        '''
        from .expr_range import ExprRange
        from proveit.core_expr_types import Len
        from proveit.numbers import Add, Mult, Neg, one
        if proven:
            return Len(ExprTuple(self)).computed(**defaults_config)
        multiplier = None
        if isinstance(self.body, ExprRange):
            # Nested ExprRanges
            num_body_elements = self.body.num_elements(proven=False)
            if self.is_parameter_independent:
                # We can simply multiply counts when the nested
                # ExprRange is independent of our parameter.
                multiplier = num_body_elements
            else:
                # Return a sum over an appropriate ExprRange.
                if (isinstance(num_body_elements, Add) and
                        num_body_elements.terms.num_entries()==1 and
                        isinstance(num_body_elements.terms[0], Add)):
                    # Ungroup this sum over an ExprRange.
                    num_body_elements = num_body_elements.terms[0]
                return Add(ExprRange(self.parameter, num_body_elements,
                                     self.start_index, self.end_index))
        # count = (end_index - start_index) + 1
        count = Add(self.end_index, 
                    Neg(self.start_index), one).quick_simplified()
        if multiplier is not None:
            if isinstance(multiplier, Mult):
                return Mult(*([count] + multiplier.factors))
            return Mult(count, multiplier)
        return count
    
    def _append_format_cell_entries(self, cell_entries):
        '''
        Append to a list of entries in correspondence with
        each format cells of an ExprTuple containing this ExprRange.
        Each entry is a pair tuple with the first item containing an 
        Expression  corresponding to the entry and the second 
        indicating the 'role'  of the cell. The beginning cells of
        the ExprRange will have consecutive integers for their role 
        starting with 0, the last cell has -1 for its role, and the 
        'ellipsis' cell has 'implicit', 'explicit', or 
        'param_independent' for its role depending upon whether it
        is parameter independent and, if not, the 'parameterization' 
        style option of the ExprRange.
        
        The assumptions dictate simplifications that may apply to
        ExprRange elements.
        '''
        from proveit.logic import InSet
        from proveit.numbers import Integer, num, Add

        index = None
        front_expansion = self.get_front_expansion()
        back_expansion = self.get_back_expansion()
        start_index = self.start_index
        end_index = self.end_index
        for _k in range(0, front_expansion):
            index = Add(start_index, num(_k)).quick_simplified()
            next_entry = self.body_replaced(index)
            if isinstance(next_entry, ExprRange):
                # Recurse through the entries of an inner ExprRange.
                next_entry._append_format_cell_entries(cell_entries)
            else:
                # Append the next entry.
                cell_entries.append((next_entry, _k))
        if self.is_parameter_independent:
            cell_entries.append((self, "param_independent"))
        else:
            parameterization = self.get_style('parameterization',
                                              'implicit')
            cell_entries.append((self, parameterization))
        for _k in range(-back_expansion, 0):
            index = Add(end_index, num(_k+1)).quick_simplified()
            next_entry = self.body_replaced(index)
            if isinstance(next_entry, ExprRange):
                # Recurse through the entries of an inner ExprRange.
                next_entry._append_format_cell_entries(cell_entries)
            else:
                # Append the next entry.
                cell_entries.append((next_entry, _k))

    def _append_format_cell_element_positions(
            self, start_element_pos, element_positions):
        '''
        Append to a list of element positions in correspondence with
        each format cell of an ExprTuple containing this ExprRange
        (see ExprTuple.get_format_cell_entries).
        Start with the given start_pos as the first position of the
        ExprRange.  The element position of an 'ellipsis' cell is
        'None' (it isn't defined).  The element position of the last
        cell will be ('end_index' - 'start_index') of the ExprRange
        added to the element position of the first cell.
        '''
        from proveit.logic import InSet
        from proveit.numbers import Integer, Add, Neg, one, num
        element_pos = start_element_pos
        front_expansion = self.get_front_expansion()
        back_expansion = self.get_back_expansion()
        start_index = self.start_index
        end_index = self.end_index
        index = None
        nested_ranges = isinstance(self.body, ExprRange)
        # Do the front expansion.
        for _k in range(0, front_expansion):
            if _k > 0:
                element_pos = Add(element_pos, one).quick_simplified()
            if nested_ranges:
                index = Add(start_index, num(_k)).quick_simplified()
            if nested_ranges:
                # Use recursion for a nested ExprRange.
                next_entry = self.body_replaced(index)
                element_pos= (
                        next_entry._append_format_cell_element_positions(
                                element_pos, element_positions))
            else:
                # Append the next element position.
                element_positions.append(element_pos)
        # Use None for the 'ellipsis' cell:
        element_positions.append(None) 
        # Set 'element_pos' to just before the first of the back
        # expansion.  Do this by going to the very end and then
        # backtracking.
        net_range_len = self.num_elements(proven=False)
        element_pos = Add(start_element_pos, net_range_len, 
                          num(-1)).quick_simplified()
        for _k in range(-back_expansion, 0):
            index = Add(end_index, num(_k+1)).quick_simplified()
            entry = self.body_replaced(index)
            range_len = ExprTuple(entry).num_elements(proven=False)
             # back up
            element_pos = Add(element_pos, Neg(range_len)).quick_simplified()
        # Do the back expansion.
        for _k in range(-back_expansion, 0):
            element_pos = Add(element_pos, one).quick_simplified()
            if nested_ranges:
                index = Add(end_index, num(_k+1)).quick_simplified()
            if nested_ranges:
                # Use recursion for a nested ExprRange.
                next_entry = self.body_replaced(index)
                element_pos= (
                        next_entry._append_format_cell_element_positions(
                                element_pos, element_positions))
            else:
                # Append the next element position.
                element_positions.append(element_pos)
        return element_pos
    
    def formatted_repeats(self, format_type):
        from proveit.numbers import Add, Neg, num
        if not self.is_parameter_independent:
            raise ValueError("'formatted_repeats' intended to be used only "
                             "when the parameter is independent.")
        after_front_expansion = Add(self.start_index, 
                                    num(self.get_front_expansion()))
        first_of_back_expansion = Add(self.end_index, 
                                      num(-self.get_back_expansion()+1))
        between_count = Add(
                first_of_back_expansion, 
                Neg(after_front_expansion)).quick_simplified()
        repeats_str = r' \times' if format_type=='latex' else ' repeats'
        return '%s%s' % (between_count.formatted(format_type, fence=True),
                         repeats_str)

    def _free_var_ranges(self, exclusions=None):
        '''
        Return the dictionary mapping Variables to forms w.r.t. ranges
        of indices (or solo) in which the variable occurs as free
        (not within a lambda map that parameterizes the base variable).
        Examples of "forms":
            x
            x_i
            x_1, ..., x_n
            x_{i, 1}, ..., x_{i, n_i}
            x_{1, 1}, ..., x_{1, n_1}, ......, x_{m, 1}, ..., x_{m, n_m}

        If this Expression is in the exclusion set, or contributes
        directly to a form that is in the exclusions set, skip over it.
        For example, given the expression
            a*x_{i, 1} + ... + a*x_{i, n_1}
        if x_{i, 1}, ..., x_{i, n_i} is in the exclusion set,
        then 'a' will be the only free variable reported.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var
        if exclusions is not None:
            if self in exclusions:
                return dict()  # this is excluded
            # For the body, extend the exclusion set as necessary to
            # exclude anything contributing directly to a form that is
            # in the exclusion set.  For example, if
            # x_1, ..., x_n is in the exclusion set and
            # self.parameter==k and self.start_index==1 and
            # self.end_index==n then add x_k to the exclusion set of
            # this body.
            body_exclusions = set(exclusions)
            for exclusion in exclusions:
                if (isinstance(exclusion, ExprRange) and
                        exclusion.start_index == self.start_index and
                        exclusion.end_index == self.end_index):
                    new_exclusion = exclusion.body.basic_replaced(
                        {exclusion.parameter: self.parameter})
                    body_exclusions.add(new_exclusion)
        else:
            body_exclusions = None
        body_forms_dict = \
            self.body._free_var_ranges(exclusions=body_exclusions)
        # deep copy body_forms_dict into forms_dict
        forms_dict = {var: set(ranges) for var, ranges
                      in body_forms_dict.items()}
        param = self.parameter
        # Eliminate the parameter; it is not a free variable.
        if param in forms_dict.keys():
            forms_dict[param].discard(param)
            if len(forms_dict[param]) == 0:
                forms_dict.pop(param)
        for expr in self._sub_expressions[1:]:
            # Skip the first sub-expression. We've already treated that.
            for var, forms in expr._free_var_ranges(
                    exclusions=exclusions).items():
                forms_dict.setdefault(var, set()).update(forms)
        # The var ranges of the body that depend upon self.parameter
        # will be promoted to expression ranges over the range of this
        # ExprRange.  For example, if x_k is one of the var ranges of
        # the body and self.parameter==k, then x_k will be replaced
        # by x_1, ..., x_n.
        for parameterized_var_range in self._parameterized_var_ranges(
                body_forms_dict):
            var = get_param_var(parameterized_var_range)
            assert var in forms_dict
            forms_dict[var].remove(parameterized_var_range)
            forms_dict[var].add(ExprRange(param, parameterized_var_range,
                                          self.start_index, self.end_index))
        return forms_dict

    def _parameterized_var_ranges(self, body_forms_dict=None):
        '''
        Yield each of body._free_var_ranges() that involves the
        ExprRange parameter as a free variable.
        For example, for ((x_1 < x_{1+1}) and ... and (x_n < x_{n+1})),
        the following will be yielded if k is the ExprRange parameter:
            x_k, x_{k+1}.
        Another example:
            a*x_{1, 1} + ... + a*x_{1, n_1} + ......
                + a*x_{m, 1} + ... + a*x_{m, n_1}
        will give
            x_{i, 1}, ..., x_{i, n_i}
        if i is the ExprRange parameter.
        '''
        if body_forms_dict is None:
            body_forms_dict = self.body._free_var_ranges()
        param = self.parameter
        for var, forms in body_forms_dict.items():
            for form in forms:
                if form == self:
                    continue
                if form == self.parameter:
                    continue  # don't count the parameter itself.
                var_forms_of_form = form._free_var_ranges()
                if (param in var_forms_of_form
                        and param in var_forms_of_form[param]):
                    yield form

    # This is NOT an @equality_prover because the returned
    # equality does not have the ExprRange directly on the left
    # side, rather it is wrapped in an ExprTuple.
    @prover
    def _range_reduction(self, must_reduce=False, **defaults_config):
        '''
        Prove this ExprRange, wrapped in an ExprTuple, equal
        to an ExprTuple form that is possibly reduced (e.g.,
        collapsed to an empty range).
        '''
        from proveit import f, i, j, m, n
        from proveit.logic import Equals
        from proveit.numbers import Add, one
        tuple_wrapped_self = ExprTuple(self)
        lambda_map = self.lambda_map
        start_index = self.start_index
        end_index = self.end_index
        if Equals(start_index, end_index).proven():
            # If we know that the start and end index are the
            # same, we can use the singular_range_reduction.
            from proveit.core_expr_types.tuples import \
                singular_range_reduction
            # return self.singular_range_reduction(
            #     {f:lambda_map, i:start_index, j:end_index},
            #      preserve_expr=tuple_wrapped_self)
            return singular_range_reduction.instantiate(
                {f:lambda_map, i:start_index, j:end_index},
                 preserve_expr=tuple_wrapped_self)
        # If the start and end are literal integers and form an
        # empty range, then it should be straightforward to
        # prove that the range is empty.
        from proveit.numbers import is_literal_int
        empty_req = Equals(Add(end_index, one), start_index)
        if is_literal_int(start_index) and is_literal_int(end_index):
            if end_index.as_int() + 1 == start_index.as_int():
                empty_req.prove()
        first = self.first()
        if empty_req.proven():
            # We can do an empty range reduction
            # Temporarily disable automation to avoid infinite
            # recursion.
            if self.nested_range_depth() > 1:
                # this is a nested range, but we know
                # that the outer range reduces to an empty range,

                # We can do an empty range reduction on the entire expression
                # Temporarily disable automation to avoid infinite
                # recursion.
                from proveit.core_expr_types.tuples import \
                    empty_outside_range_of_range
                nest_end_index = first.end_index
                nest_start_index = first.start_index
                lambda_map = Lambda(
                    (self.parameter, self.body.parameter), self.body.body)
                return empty_outside_range_of_range.instantiate(
                    {f: lambda_map, m: start_index, n: end_index,
                     i: nest_start_index, j: nest_end_index},
                     preserve_expr=tuple_wrapped_self)
            else:
                from proveit.core_expr_types.tuples import \
                    empty_range_def
                # Preserve 'self' on the left side of the reduction.
                return empty_range_def.instantiate(
                    {f: lambda_map, i: start_index, j: end_index},
                    preserve_expr=tuple_wrapped_self)
        elif self.nested_range_depth() > 1:
            # this is a nested range so the inner range could be empty.

            # If the start and end of the inner range are literal
            # integers and form an empty range, then it should be
            # straightforward to prove that the entire range is empty.
            from proveit.numbers import is_literal_int
            empty_req = Equals(
                Add(first.end_index, one), first.start_index)
            if is_literal_int(
                    first.start_index) and is_literal_int(
                    first.end_index):
                if first.end_index.as_int() + \
                        1 == first.start_index.as_int():
                    empty_req.prove()
            if empty_req.proven():
                # We can do an empty range reduction on the entire expression
                # Temporarily disable automation to avoid infinite
                # recursion.
                from proveit.core_expr_types.tuples import \
                    empty_inside_range_of_range
                # Preserve 'self' on the left side of the reduction.
                nest_end_index = first.end_index
                nest_start_index = first.start_index
                lambda_map = Lambda(
                    (self.parameter, self.body.parameter), 
                    self.body.body)
                return empty_inside_range_of_range.instantiate(
                    {f: lambda_map, m: start_index, n: end_index, 
                     i: nest_start_index, j: nest_end_index},
                     preserve_expr=tuple_wrapped_self)
        # If nothing else is applicable, we will return the trivial 
        # reflexive equality.
        if must_reduce:
            # Nothing can be reduced, so raise an exception.
            raise UnsatisfiedPrerequisites("%s is not provably "
                                           "reducible"%self)
        return Equals(tuple_wrapped_self, 
                      tuple_wrapped_self).conclude_via_reflexivity()

    def _possibly_reduced_range_entries(self, requirements):
        '''
        If the given ExprRange has a reduction (as an empty), 
        add this reduction as a requirement and yield the
        entries of the reduced version.  Otherwise, just yield
        the original expr_range.
        '''
        try:
            reduction = self._range_reduction(must_reduce=True)
        except UnsatisfiedPrerequisites:
            yield self
        if reduction.lhs != reduction.rhs:
            requirements.append(reduction)
        for entry in reduction.rhs:
            yield entry

    def _replaced_entries(self, repl_map, allow_relabeling, requirements):
        '''
        Returns this expression with sub-expressions replaced
        according to the replacement map (repl_map) dictionary.

        'requirements' (and defaults.assumptions) are used when an 
        operator is replaced by a Lambda map that has a range of 
        parameters such that the length of the parameters and operands 
        must be proven to be equal.  See the Operation.replaced and 
        Lambda.apply documentation for more details.
        
        If the start and end indices of the ExprRange are replaced
        with the same expression, just the single instance will
        be yielded.

        Expansion replacements of a range of indexed variables must
        be made explicit for the corresponding range (and therefore
        unambiguous and direct).  For example, to expand x in the
        following expression
            (x_1 < x_{1+1}) and ... and (x_n < x_{n+1})
        there must be a replacement in repl_map for
        (x_1, ..., x_n) as well as (x_{1+1}, ..., x_{n}).
        In an instantiation, this can be done by supplying
        instantiations of multiple forms of ranges of x.  For example:
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{1+1}, ..., d_{n+1})
        where the following requirements must be satisfied:
            (1, ..., n, n+1) = (1, ..., n+1)
            (1, 1+1, ..., n+1) = (1, ..., n+1)
            (a_1, ..., a_n, b) = (c, d_{1+1}, ..., d_{n+1})

        When multiple indexed variables are expanded within the
        ExprRange, the expansions must be in exact correspondence
        with respect to range start and index indices of the expansion.
        The above example meets this requirement since
            a_1, ..., a_n
            matches with
            b_{1+1}, ..., b_{n+1}
            by both being ranges from 1 to n.
        This expansion would fail this requirement
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{2}, ..., d_{n+1})
        since d_{2}, ..., d_{n+1} is a range from 2 to n+1.

        Here is another valid instantiation:
            (x_1, ..., x_n, x_{n+1}) :
                (a_1, ..., a_n, a_{n+1}, b_1, ..., b_n, b_{n+1})
            (x_1, x_{1+1}, ..., x_{n+1}) :
                (a_1, a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1})
        since
             a_1, ..., a_n, a_{n+1}, b_1, ..., b_n
             matches with
             a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1}
             with the pattern: 1 to n, single element, 1 to n.

        See the Lambda.apply documentation for a related discussion.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var, extract_param_replacements
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.logic import Equals  # , InSet
        from proveit.numbers import Add, one  # , Interval

        if len(repl_map) > 0 and (self in repl_map):
            # The full expression is to be replaced.
            return repl_map[self]

        # Do replacements for the start and end indices.
        subbed_start_index, subbed_end_index = (
                sub_expr.basic_replaced(
                    repl_map, allow_relabeling=allow_relabeling,
                    requirements=requirements)
            for sub_expr in (self.start_index, self.end_index))
        # See if we should reduce to a singular instance, according to
        # whether the start and end indices are the same.
        if subbed_start_index==subbed_end_index:
            yield self._singular_reduced(
                    repl_map, _subbed_index=subbed_start_index,
                    allow_relabeling=allow_relabeling,
                    requirements=requirements)
            return

        if requirements is None:
            requirements = []
        # We will turn on the `indices_must_match` flag when the
        # replacement index ranges must match the original range of
        # indices and not just match in length:
        indices_must_match = False
        # Stash anything we temporarily pop out of the repl_map.
        repl_map_stash = dict()

        # `var_range_forms` maps variables to the set of equivalent
        # forms of indexing over a range pertinent to getting the
        # replaced entries of this ExprRange.
        # Remove them from the `repl_map` temporarily.
        var_range_forms = dict()
        expanding_occurrences = set()
        parameterized_var_ranges = list(self._parameterized_var_ranges())
        for occurrence in parameterized_var_ranges:
            # `occurrence` may be something like x_k or
            # x_{k,1}, ..., x_{k,n}
            # where `k` is `self.parameter`.
            # If repl_map maps `x` to a set, in this example,
            # then it has an expansion for any of the forms that
            # are contained in the set.
            var = get_param_var(occurrence)
            if var in var_range_forms:
                expanding_occurrences.add(occurrence)
                # Already added this `var` to `var_expansion_forms` and
                # removed it from `repl_map`:
                continue
            repl = repl_map.get(var, None)
            if isinstance(repl, set):
                expanding_occurrences.add(occurrence)
                var_range_forms[var] = repl
                repl_map_stash[var] = repl_map.pop(var)
            elif not indices_must_match:
                # If some variables are expanded but others are not,
                # our replacement index ranges will need to match the
                # original range of indices to be a valid replacement.
                indices_must_match = True
                reason_indices_must_match = var  # temporary assignment
        if len(var_range_forms) > 0:
            expanding_var = next(iter(var_range_forms))
            if indices_must_match:
                # `reason_indices_must_match` was temporarily assigned
                # to a Variable that is not being expanded.  Change it
                # to a proper message now that we have a variable that
                # is being expanded.
                reason_indices_must_match = (
                    "not all of the indexed variables being indexed "
                    "by the ExprRange parameter are being expanded "
                    "(%s is expanded but %s is not)"
                    % (expanding_var, reason_indices_must_match))
        else:
            # Nothing fancy, just basic_replaced of the expression.
            yield self.basic_replaced(
                repl_map, allow_relabeling=allow_relabeling,
                requirements=requirements,
                _subbed_start_index=subbed_start_index,
                _subbed_end_index=subbed_end_index)
            return

        # Need to handle the change in scope within the lambda
        # expression.
        # Note, we should have already gotten requirements
        # when calling self.replaced.
        dummy_reqs = []
        new_params, inner_repl_map, inner_assumptions \
            = self.lambda_map._inner_scope_sub(
                    repl_map, allow_relabeling, dummy_reqs)

        # Sanity check that we didn't introduce new requirements.
        # "_inner_scope_sub" should not introduce anything that
        # wasn't introduced when we called `self.replaced`.
        prev_reqs = set(requirements)
        for req in dummy_reqs:
            assert req in prev_reqs

        assert len(new_params) == 1
        new_param = new_params[0]
        safe_dummy_var = safe_dummy_var(self.body, self.parameter)
        # Restore the repl_map, adding back in what was temporarily
        # popped out.
        repl_map.update(repl_map_stash)

        # If the range parameter is used for anything other than an
        # index of an indexed variable, or not all of the
        # parameterized_var_ranges are expanded, all of the new indices
        # must match the original indices, not just the length.
        excluded_var_ranges = \
            self.body._free_var_ranges(
                exclusions=parameterized_var_ranges)
        if self.parameter in excluded_var_ranges:
            indices_must_match = True
            reason_indices_must_match = (
                "the ExprRange parameter appears outside of IndexedVar "
                "indices")

        # Create `expansions_dict` to map each of the variables being
        # expanded to the expansion that is relevent for this ExprRange.
        expansions_dict = dict()
        #orig_parameters = extract_parameters(self)
        #starts = extract_start_indices(subbed_expr_range)
        #ends = extract_end_indices(subbed_expr_range)
        orig_parameter = self.parameter
        #assert len(starts)==len(ends)==len(orig_parameters)
        for occurrence in expanding_occurrences:
            # We need to create a proper "variable range" with simple
            # parameterized indices.  Any shifts of the indices of
            # the indexed_var_or_range must be absorbed into the
            # starting/ending indices.  For example
            # x_{k+1} with k going from 1 to n should change to
            # x_k with k going from 1+1 to n+1.
            indexed_var = innermost_body(occurrence)
            var_indices = indexed_var.indices
            var = indexed_var.var

            param_index = None

            # Note: We'll make replacements of IndexedVar indices and 
            # start and end range indices of the occurrence, but not the
            # variable itself, before we look up the replacement for the
            # corresponding variable range.
            occurrence_map = dict(repl_map)
            occurrence_map.pop(var)
            for idx in var_indices:
                if orig_parameter in free_vars(idx):
                    if param_index is not None:
                        raise ImproperReplacement(
                            self, repl_map,
                            "Failure to expand %s because %s is not a valid "
                            "occurrence with the range parameter %s; multiple "
                            "index occurrences are not allowed."
                            % (self, occurrence, orig_parameter))
                    start_with_absorbed_shift = \
                        idx.basic_replaced(
                                {orig_parameter: subbed_start_index})
                    end_with_absorbed_shift = \
                        idx.basic_replaced({orig_parameter: subbed_end_index})
                    param_index = idx
                    occurrence_map[idx] = orig_parameter
                    if idx != orig_parameter:
                        # We'll map the original parameter to a safe 
                        # dummy var so we can detect if there are other 
                        # instances of the original parameter with a 
                        # different shift.
                        occurrence_map[orig_parameter] = safe_dummy_var
            if param_index is None:
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s is not a valid "
                    "occurrence with the range parameter %s; not used as "
                    "an index."
                    % (self, occurrence, orig_parameter))
            orig_occurrence = occurrence
            occurrence = occurrence.basic_replaced(
                occurrence_map, allow_relabeling=allow_relabeling, 
                requirements=requirements)
            if safe_dummy_var in free_vars(occurrence):
                # There was an instance of the original parameter with a
                # different shift than what we used.  That's not allowed.
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s does not use a "
                    "consistent shift the range parameter %s."
                    % (self, orig_occurrence, orig_parameter))

            var_range = ExprRange(orig_parameter, occurrence,
                                  start_with_absorbed_shift,
                                  end_with_absorbed_shift)

            # Now wrap this "variable range" in an ExprTuple and see
            # if it has a known expansion.
            var_tuple = ExprTuple(var_range)
            var = get_param_var(occurrence)
            if var_tuple not in inner_repl_map:
                def key_var(key): return (get_param_var(key[0]) if
                                          isinstance(key, ExprTuple)
                                          else get_param_var(key))
                var_replacements = \
                    {key: value for key, value in inner_repl_map.items() if
                     key_var(key) == var}
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because there is no explicit "
                    "expansion for %s.  The known expansions for "
                    "this variable are %s.  "
                    "(Note that multiple, equivalent expansion forms "
                    "may be provided to fulfill this requirement)."
                    % (self, var_tuple, var_replacements))
            repl = inner_repl_map.pop(var_tuple)
            if not isinstance(repl, ExprTuple):
                raise ImproperReplacement(
                    self, repl_map,
                    "Invalid replacement %s for %s; it must be an "
                    "ExprTuple." % (var_tuple, repl))
            expansions_dict[occurrence] = repl.entries

        def raise_failed_expansion_match(first_expansion, expansion,
                                         first_indexed_var_or_range,
                                         indexed_var_or_range):
            raise ImproperReplacement(
                self, repl_map,
                "When expanding IndexedVar's within an ExprRange whose "
                "parameter is the index, their expansion ExprRange "
                "indices must all match. %s vs %s do not match as "
                "respected expansions for %s and %s."
                % (first_expansion, expansion,
                   first_indexed_var_or_range, indexed_var_or_range))

        # Do we need to match the new indices to the original indices?
        if indices_must_match:
            # Yes.  Prepare to do that.
            new_indices = []
            next_index = subbed_start_index

        # Divy up the expansions into aligned entries, each with
        # its own replacement map.  This is in preparation to yield
        # a replaced version of the body for each of these entries.
        # Each entry is either singular (at this level) or an ExprRange
        # (where we will yield a new ExprRange covering a portion of
        # the original ExprRange).  The "alignment" of the entries
        # means that corresponding ExprRange entries must have the
        # same start and end indices (i.e., for different expansions).
        body = self.body
        entry_repl_maps = None
        # This will be a list with only the ExprRange entries and None
        # for non-ExprRange entries.
        first_expansion_entry_ranges = None
        for indexed_var_or_range, expansion in expansions_dict.items():
            parameters = [indexed_var_or_range]
            parameter_vars = [get_param_var(indexed_var_or_range)]
            expansion_iter = iter(expansion)
            # Replacement maps corresponding with this
            # 'indexed_var_or_range' and 'expansion'.
            expansion_repl_maps = []
            expansion_entry_ranges = []
            while True:
                entry_repl_map = dict()
                # Peek ahead; get the next entry without advancing the
                # iter.
                head, expansion_iter = more_itertools.spy(expansion_iter)
                if len(head) == 0:
                    break  # No more entries.
                # See if the next entry is to be a proper ExprRange
                # entry at this level.
                entry = head[0]
                if (isinstance(entry, ExprRange) and
                        is_at_same_nested_range_level(indexed_var_or_range,
                                                      entry.body)):
                    # This is a proper ExprRange entry (at this level).
                    # The replacement map will map
                    # 'indexed_var_or_range' to the body of the entry
                    # with the parameter changed to our 'new_param'.
                    param_repl_map = {entry.parameter: new_param}
                    new_body = entry.body.basic_replaced(param_repl_map)
                    entry_repl_map[indexed_var_or_range.basic_replaced(
                        param_repl_map)] = new_body
                    expansion_entry_ranges.append(entry)
                    # Advance the "expansion iter".
                    next(expansion_iter)
                else:
                    # This is not a proper ExprRange entry.  It may
                    # be a simple singular entry, or multiple entries
                    # for a nested ExprRange (which is why we need
                    # to use the 'extract_param_replacements' method).
                    extract_param_replacements(
                        parameters, parameter_vars, body,
                        expansion_iter, None,
                        requirements, entry_repl_map)
                    # Mark as a non-ExprRange entry by simply appending
                    # None.
                    expansion_entry_ranges.append(None)
                expansion_repl_maps.append(entry_repl_map)
            if first_expansion_entry_ranges is None:
                # This is the first expansion we are processing.
                entry_repl_maps = expansion_repl_maps
                first_expansion_entry_ranges = expansion_entry_ranges
                first_expansion = expansion
                first_indexed_var_or_range = indexed_var_or_range
            else:
                # We have processed other expansions.  Make sure
                # they are consistent w.r.t. ExprRange entries
                # and total number of entries.
                if len(first_expansion_entry_ranges) != len(
                        expansion_entry_ranges):
                    # Failing to have the same number of entries.
                    raise_failed_expansion_match(
                        first_expansion, expansion,
                        first_indexed_var_or_range,
                        indexed_var_or_range)
                for first_expansion_entry, expansion_entry in zip(
                        first_expansion_entry_ranges, expansion_entry_ranges):
                    if (isinstance(expansion_entry, ExprRange)
                            != isinstance(first_expansion_entry, ExprRange)):
                        # Failing to match w.r.t. being an ExprRange
                        # entry or not.
                        raise_failed_expansion_match(
                            first_expansion, expansion,
                            first_indexed_var_or_range,
                            indexed_var_or_range)
                    if isinstance(expansion_entry, ExprRange):
                        if (expansion_entry.start_index
                                != first_expansion_entry.start_index):
                            # Failed to have the same ExprRange range
                            # (different start).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                        if (expansion_entry.end_index !=
                                first_expansion_entry.end_index):
                            # Failed to have the same ExprRange range
                            # (different end).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                # Combine the 'expansion_repl_maps' into the
                # 'entry_repl_maps' for all expansions.
                for entry_repl_map, expansion_repl_map in zip(
                        entry_repl_maps, expansion_repl_maps):
                    entry_repl_map.update(expansion_repl_map)

        def update_map(orig_repl_map, update):
            '''
            Given an original replacement map, use the 'update' dictionary
            to make replacements in all of its keys and values and then
            add the update entrie(s).
            '''
            new_repl_map = dict()
            for key, val in orig_repl_map.items():
                key = key.basic_replaced(update)
                if isinstance(val, set):
                    val = {elem.basic_replaced(update) for elem in val}
                else:
                    val = val.basic_replaced(update)
                new_repl_map[key] = val
            new_repl_map.update(update)
            return new_repl_map

        # Yield a replacement for each of the aligned entry of the
        # expansions.  May be a singular entry or an ExprRange entry
        # representing a portion of the original range.
        for first_expansion_entry_range_or_none, entry_repl_map in zip(
                first_expansion_entry_ranges, entry_repl_maps):
            # Use the 'inner replacement map' updated with the
            # 'entry replacement map' to get the 'full entry replacment
            # map'.
            full_entry_repl_map = dict(inner_repl_map)
            full_entry_repl_map.update(entry_repl_map)
            # Now yield the substitution corresponding to this entry.
            if first_expansion_entry_range_or_none is not None:
                assert isinstance(first_expansion_entry_range_or_none,
                                  ExprRange)
                # For an ExprRange entry, yield a new ExprRange
                # representing a portion of th eoriginal range.
                first_expansion_entry = first_expansion_entry_range_or_none
                start_index = first_expansion_entry.start_index
                end_index = first_expansion_entry.end_index

                # Let's keep this simple and not worry about this
                # "range assumptions".
                # If needed, we can use explicit axioms/theorems to
                # make use of this property rather than in the core.
                # If we change our minds, the range assumption should
                # also be employed in the ExprRange._replaced method.
                # range_assumption = InSet(new_param,
                #                         Interval(start_index, end_index))

                entry_assumptions = inner_assumptions  # + [range_assumption]
                param_repl_map = {orig_parameter: new_param}
                full_entry_repl_map = update_map(
                    full_entry_repl_map, param_repl_map)
                with defaults.temporary() as temp_defaults:
                    temp_defaults.assumptions = entry_assumptions
                    entry = ExprRange(
                            new_param,
                            body.basic_replaced(
                                    full_entry_repl_map,
                                    allow_relabeling=allow_relabeling,
                                    requirements=requirements),
                            start_index, end_index)
                yield entry
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(ExprRange(new_param, new_param,
                                                 start_index, end_index))
                    next_index = Add(end_index, one)
            else:
                # For a singular element entry, yield the replaced
                # element.
                if indices_must_match:
                    # Attempt to simplify the 'next_index' only when
                    # we need it.
                    next_index = next_index.equality_replaced(
                        requirements, auto_simplify_top_level=True)
                    # The actual range parameter index is needed:
                    param_repl_map = {orig_parameter: next_index}
                    full_entry_repl_map = update_map(
                        full_entry_repl_map, param_repl_map)
                    #full_entry_repl_map[orig_parameter] = next_index

                with defaults.temporary() as temp_defaults:
                    temp_defaults.assumptions = inner_assumptions
                    if isinstance(body, ExprRange):
                        # A nested ExprRange may need to be expanded.
                        for subentry in body._replaced_entries(
                                full_entry_repl_map, allow_relabeling,
                                requirements):
                            yield subentry
                    else:
                        yield body.basic_replaced(
                                full_entry_repl_map, 
                                allow_relabeling=allow_relabeling,
                                requirements=requirements)

                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(next_index)
                    next_index = Add(next_index, one)

        if indices_must_match:
            # The range parameter appears outside of
            # IndexedVars.  That means that we must match new
            # and original indices precisely, not just their length.
            requirement = Equals(ExprTuple(*new_indices),
                                 ExprTuple(ExprRange(new_param, new_param,
                                                     subbed_start_index,
                                                     subbed_end_index)))
            if requirement.lhs == requirement.rhs:
                # No need for the requirement if it is a trivial
                # reflexive identity.
                return
            try:
                requirements.append(requirement.prove())
            except ProofFailure as e:
                raise ImproperReplacement(
                    self, repl_map,
                    "ExprRange indices failed to match expansion "
                    "which is necessary because %s: %s."
                    % (reason_indices_must_match, e))

    def parameters(self):
        '''
        Return a list of parameters, one for each nested
        ExprRange.
        '''
        return extract_parameters(self)

    def innermost_body(self):
        '''
        Return the innermost body of a nested ExprRange.
        '''
        return innermost_body(self)

    def start_indices(self):
        '''
        Return a list of starting indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has start indices (m, i_m).
        '''
        return extract_start_indices(self)

    def end_indices(self):
        '''
        Return a list of ending indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has end indices (n, j_n).
        '''
        return extract_end_indices(self)

    def mapped_range(self, body_map_fn):
        '''
        Generate an ExprRange with the same external structure
        as this range but converts the innermost by applying the
        'body_map_fn' to it.
        '''
        inner_body = self.innermost_body(self)
        new_inner_body = body_map_fn(inner_body)
        parameters = extract_parameters(self)
        start_indices = extract_start_indices(self)
        end_indices = extract_end_indices(self)
        return nested_range(parameters, new_inner_body, start_indices,
                            end_indices)

    @prover
    def partition(self, before_split_idx, **defaults_config):
        '''
        Return the equation between this range within an ExprTuple
        and a split version in the following manner:
            (f(self.start_index), ..., f(self.end_index)) =
            (f(self.start_index), ..., f(before_split_index),
             f(before_split_index+1), ..., f(self.end_index))
        where f represents the self.lambda_map.
        '''
        from proveit import f, i, j, k
        from proveit.logic import Equals
        from proveit.numbers import Add, one, subtract
        from proveit.core_expr_types.tuples import (
            range_extension_def)
        from proveit.core_expr_types.tuples import (
            partition_front, partition_back, partition)

        lambda_map = self.lambda_map
        start_index, end_index = self.start_index, self.end_index
        if end_index == Add(before_split_idx, one):
            # special case which uses the axiom:
            return range_extension_def.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx})
        elif before_split_idx == self.start_index:
            # special case when peeling off the front
            return partition_front.instantiate(
                {f: lambda_map, i: self.start_index, j: self.end_index})
        elif (before_split_idx == subtract(end_index, one) or
              Equals(before_split_idx, subtract(end_index, one)).proven()):
            # special case when peeling off the back
            return partition_back.instantiate(
                {f: lambda_map, i: start_index, j: end_index})
        else:
            return partition.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx,
                 k: end_index})

    @prover
    def shift_equivalence(self, *, old_shift=None, new_start=None,
                          new_end=None, new_shift=None,
                          **defaults_config):
        '''
        Return the equation between this range within an ExprTuple
        and a shifted version in the following manner:
            (f(self.start_index+old_shift), ..., f(self.end_index+old_shift)) =
            (f(new_start+new_shift), ..., f(new_start+new_shift))
        where f is adapted from self.lambda_map according to 'old_shift'.
        If any of the 'new' parameters are unspecified, we attempt
        to deduce them from the other parameters.
        '''
        from proveit import a, b, f, i, j, k, l
        from proveit.numbers import Add, Neg, subtract
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.core_expr_types.tuples import (
            shift_equivalence, shift_equivalence_both)

        if old_shift is None:
            _f = self.lambda_map
        else:
            old_shifted_param = Add(self.parameter, old_shift)
            safe_var = safe_dummy_var(self.body)
            shifted_body = self.body.basic_replaced({old_shifted_param: safe_var})
            if self.parameter in free_vars(shifted_body):
                raise ValueError("The given 'old_shift' of %s does apply "
                                 "to %s" % (old_shift, self.lambda_map))
            _f = Lambda(self.parameter,
                        shifted_body.basic_replaced({safe_var: self.parameter}))

        _i, _j = self.start_index, self.end_index

        if new_shift is not None:
            net_shift = new_shift
            if old_shift is not None:
                net_shift = subtract(new_shift, old_shift).simplified()
            if new_start is None:
                # new start = _i - new_shift
                new_start = subtract(_i, net_shift).simplified()
            if new_end is None:
                # new_end = _j - new_shift
                new_end = subtract(_j, net_shift).simplified()
        elif new_start is None:
            # new_start = new_end + i - j
            new_end = Add(new_start, _i, Neg(_j)).simplified()
        elif new_end is None:
            # new_end = new_start + j - i
            new_end = Add(new_start, _j, Neg(_i)).simplified()

        _k, _l = new_start, new_end

        if new_shift is None:
            # Compute the new shift based upon the other parameters.
            if old_shift is None:
                new_shift = subtract(_i, _k).simplified()
            else:
                new_shift = Add(_i, old_shift, Neg(_k)).simplified()

        if old_shift is None:
            return shift_equivalence.instantiate(
                {f: _f, a: new_shift, i: _i, j: _j, k: _k, l: _l})
        else:
            return shift_equivalence_both.instantiate(
                {f: _f, a: old_shift, b: new_shift, i: _i, j: _j, k: _k, l: _l})

    """
    def _var_index_shifts_in_ranges(self, var, shifts):
        '''
        Given a 'var' (e.g., 'x'), pass back, via the set 'shifts',
        all of the constant indexed shifts to the ExprRange parameter
        within ExprRanges (e.g., 'x_{1+1}, ..., x_{n+1}' would have
        presumably have a shift of 1).
        '''
        self.body._indexed_var_shifts(var, self.parameter, shifts)
        Expression._var_index_shifts_in_ranges(self, var, shifts)
    """

    """
    TODO: change register_equivalence_method to allow and fascilitate these
    method stubs for purposes of generating useful documentation.

    def partitioned(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the right-hand-side of a 'partition'.
        '''
        raise Exception("Should be implemented via InnerExpr.register_equivalence_method")

    def split(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        As an InnerExpr method when the inner expression is an ExprRange,
        return the expression with the inner expression replaced by its
        'partitioned' version.
        '''
        raise Exception("Implemented via InnerExpr.register_equivalence_method "
                        "only to be applied to an InnerExpr object.")
    """


def _has_expansion(var_form, repl_map):
    '''
    Return True if and only if the given IndexedVar has
    an expansion in the given replacement map.
    '''
    from proveit._core_.expression.lambda_expr.lambda_expr import \
        get_param_var
    var_repl = repl_map.get(get_param_var(var_form), None)
    # When being expanded, a set of equivalent tuples of
    # indexed variables is used as the direct variable
    # replacement (e.g. x : {(x_1, ..., x_{n+1}),
    #                        (x_1, ..., x_n, x_{n+1})}).
    return isinstance(var_repl, set)


def extract_start_indices(expr_range):
    '''
    Return a list of starting indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has start indices (m, i_m).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        start_index = expr.start_index
        subbed_index = start_index.basic_replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_end_indices(expr_range):
    '''
    Return a list of ending indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has end indices (n, j_n).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        end_index = expr.end_index
        subbed_index = end_index.basic_replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_parameters(expr_range):
    '''
    Return a list of parameters, one for each nested
    ExprRange.
    '''
    parameters = []
    expr = expr_range
    while isinstance(expr, ExprRange):
        parameters.append(expr.parameter)
        expr = expr.body
    return parameters


def innermost_body(expr_range):
    '''
    Return the innermost body of a nested ExprRange.
    '''
    expr = expr_range
    while isinstance(expr, ExprRange):
        expr = expr.body
    return expr


def is_at_same_nested_range_level(expr1, expr2):
    '''
    Return True iff 'expr1' and 'expr2' are either both
    ExprRanges, or nested ExprRanges at the same number of levels.
    '''
    while True:
        if isinstance(expr1, ExprRange) != isinstance(expr2, ExprRange):
            # Levels don't match.
            return False
        if not isinstance(expr1, ExprRange):
            # Made it to the end without encountering a mismatch.
            return True
        # Go another level deeper.
        expr1 = expr1.body
        expr2 = expr2.body


def nested_range(parameters, body, start_indices, end_indices):
    if len(parameters) > 1:
        # multiple levels
        inner_body = nested_range(parameters[1:], body,
                                  start_indices[1:], end_indices[1:])
    else:
        # single level
        inner_body = body
    if start_indices[0] == end_indices[0]:
        # When the start and end indices are the same, reduce it
        # to a single instance.
        return inner_body.basic_replaced({parameters[0]: start_indices[0]})
    return ExprRange(parameters[0], inner_body,
                     start_indices[0], end_indices[0])

def var_range(var, start_index_or_indices, end_index_or_indices):
    from proveit import (safe_dummy_vars, composite_expression,
                         IndexedVar)
    start_indices = composite_expression(start_index_or_indices)
    end_indices = composite_expression(end_index_or_indices)
    parameters = safe_dummy_vars(start_indices.num_entries(), var, 
                                 start_indices, end_indices)
    return nested_range(parameters, IndexedVar(var, parameters),
                        start_indices, end_indices)


class RangeInstanceError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg
