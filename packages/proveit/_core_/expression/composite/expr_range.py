import more_itertools

from proveit._core_.expression.expr import (Expression, MakeNotImplemented,
                                            ImproperReplacement,
                                            free_vars)
from proveit._core_.expression.style_options import StyleOptions
from proveit._core_.expression.lambda_expr.lambda_expr import Lambda
from proveit._core_.expression.composite import singular_expression, ExprTuple
from proveit._core_.expression.conditional import Conditional
from proveit._core_.proof import ProofFailure
from proveit._core_.defaults import defaults, USE_DEFAULTS


class ExprRange(Expression):
    '''
    An ExprRange expression represents a range of "element" expressions
    within a containing ExprTuple.  It represents this as a Lambda to
    map each valid index value to a corresponding element, along with a
    start and end index value.  The represented element sequence
    corresponds to index values going from the start to the end in
    increments of 1, ranging over index values.

    For example,
    1/i + ... + 1/j
    is internall represented by an Add operation with the following as
    its "operands":
    (1/i, ..., 1/j).
    These "operands" are represented by an ExprTuple with a single
    "entry" which is an ExprRange whose `lambda_map` is "k |-> 1/k",
    `start_index` is "i", and `end_index` is "j".  An ExprTuple "entry"
    may generally either be a singuler element or an ExprRange that
    represents multiple elements.
    '''

    def __init__(self, parameter, body, start_index, end_index, *,
                 parameterization=None, lambda_map=None):
        '''
        Create an ExprRange that represents a range of expressions
        to be embedded within an ExprTuple.  Each element of the
        range is generated by mapping the parameter according to the
        body with the parameter ranging from the start index to the
        end index.
        A Lambda expression will be created as its first sub-expression.
        The start and end indices with be the second and third
        sub-expressions.

        The 'parameterization' sets the style for formatting the
        ExprRange.  The default is "implicit" for LaTeX formatting
        but "explicit" for string formatting.  Since string formatting
        is most often used for error messages, it is useful to have
        the full "explicit" version.

        The lambda_map may be used instead of supplying the parameter
        and body, in which case the 'parameter' and 'body' arguments
        must both be None.
        '''
        if lambda_map is not None:
            # Use the provided 'lambda_map' instead of creating one.
            lambda_map = lambda_map
            if (parameter, body) != (None, None):
                raise ValueError("'parameter' and 'body' arguments of the "
                                 "ExprRange constructor should be None if "
                                 "lambda_map is provided.")
            parameter = lambda_map.parameter
        else:
            lambda_map = Lambda(parameter, body)
        if parameterization not in (None, 'implicit', 'explicit'):
            raise ValueError("'parameterization' must be 'implicit', "
                             "'explicit', or None; not %s" % parameterization)
        styles = ({'parameterization': parameterization} if
                  parameterization is not None else dict())

        Expression.__init__(self, ['ExprRange'],
                            [lambda_map, start_index, end_index],
                            styles=styles)
        self.start_index = singular_expression(start_index)
        self.end_index = singular_expression(end_index)
        self.lambda_map = lambda_map
        # The body of the Lambda map is a Conditional that conditions the
        # mapping according to the parameter being in the [start, end]
        # interval.  We'll use self.body to refer to the value of this
        # conditional.
        self.parameter = self.lambda_map.parameter
        self.body = self.lambda_map.body
        self.is_parameter_independent = (
            self.parameter not in
            free_vars(self.body, err_inclusively=True))

    @classmethod
    def _make(sub_class, core_info, sub_expressions):
        if sub_class != ExprRange:
            MakeNotImplemented(sub_class)
        if len(core_info) != 1 or core_info[0] != 'ExprRange':
            raise ValueError("Expecting ExprRange core_info to contain "
                             "exactly one item: 'ExprRange'")
        lambda_map, start_index, end_index = sub_expressions
        return ExprRange(None, None, start_index, end_index,
                         lambda_map=lambda_map)

    def literal_int_extent(self):
        '''
        If the start and end indices of this ExprRange are literal integers,
        return the literal number of elements of the ExprRange.  For the
        case of nested ExprRange's, all of the start and end indices must
        be integers and the result will be the multiplied extent.  For
        example:
            a_{1,1}, ..., a_{1,3}, ......, a_{4,1}, ..., a_{4,3}
        has a literal_int_extent of 12.
        '''
        from proveit.numbers import is_literal_int
        if (is_literal_int(self.start_index) and is_literal_int(self.end_index)):
            toplevel_extent = (
                self.end_index.as_int() -
                self.start_index.as_int() +
                1)
            if isinstance(self.body, ExprRange):
                return toplevel_extent * self.body.literal_int_extent()
            else:
                return toplevel_extent
        raise ValueError(
            "literal_int_extent may only be used on an ExprRange  "
            "with start and end indices that are literal integers")

    def remake_arguments(self):
        '''
        Yield the argument values or (name, value) pairs
        that could be used to recreate the ExprRange.
        '''
        yield self.lambda_map.parameter
        yield self.lambda_map.body
        yield self.start_index
        yield self.end_index

    def remake_with_style_calls(self):
        '''
        In order to reconstruct this Expression to have the same styles,
        what "with..." method calls are most appropriate?  Return a
        tuple of strings with the calls to make.  The default for the
        Operation class is to include appropriate 'with_wrapping_at'
        and 'with_justification' calls.
        '''
        call_strs = []
        parameterization = self.get_style('parameterization', 'default')
        if parameterization != 'default':
            if parameterization == 'explicit':
                call_strs.append('with_explicit_parameterization()')
            if parameterization == 'implicit':
                call_strs.append('with_implicit_parameterization()')
        return call_strs

    def style_options(self):
        options = StyleOptions(self)
        options.add_option(
            name = 'parameterization',
            description = (
                    "'implicit' (default for LaTeX formatting) hides "
                    "the parameter the ExprRange so the parameterization "
                    "may be ambiguous (e.g., x_{1+1}, ..., x_{n+1}); "
                    "'explicit' (default for string formatting) reveals "
                    "the parameterization "
                    "(e.g. x_{1+1}, ..x_{k+1}.., x_{n+1})."),
            default = None,
            related_methods = ('with_explicit_parameterization',
                               'with_implicit_parameterization',
                               'with_default_parameterization_style'))
        return options

    def with_explicit_parameterization(self):
        '''
        The 'parameterization':'explicit' style shows the
        parameterization of the ExprRange explicitly.  For example,
        x_{1+1}, ..x_{k+1}.., x_{n+1}).
        '''
        return self.with_styles(parameterization='explicit')

    def with_implicit_parameterization(self):
        '''
        The 'parameterization':'implicit' style does not show the
        parameterization of the ExprRange explicitly and such that the
        parameterization may be ambiguous but is more compact.
        For example, x_{1+1}, ..., x_{n+1} could be
        x_{1+1}, ..x_{k+1}.., x_{n+1}
        or could be
        x_{1+1}, ..x_{k}.., x_{n+1}.
        '''
        return self.with_styles(parameterization='implicit')

    def with_default_parameterization_style(self):
        '''
        The default is to use an 'implicit' parameterization for
        string formatting (see 'with_implicit_parameterization') and
        and 'explicit' parameterization for LaTeX formatting
        (see 'with_explicit_parameterization').
        '''
        return self.without_style('parameterization')

    def first(self):
        '''
        Return the first instance of the range
        (and store for future use).
        '''
        if not hasattr(self, '_first'):
            expr_map = {self.lambda_map.parameter: self.start_index}
            self._first = self.body.replaced(expr_map)
        return self._first

    def last(self):
        '''
        Return the last instance of the range
        (and store for future use).
        '''
        if not hasattr(self, '_last'):
            expr_map = {self.lambda_map.parameter: self.end_index}
            self._last = self.body.replaced(expr_map)
        return self._last

    def string(self, **kwargs):
        return self.formatted('string', **kwargs)

    def latex(self, **kwargs):
        return self.formatted('latex', **kwargs)

    def nested_range_depth(self):
        '''
        Return the depth of nested ranges.  For example, if this
        is a simple range with no nesting, return 1.
        If this is a range of simple ranges, return 2.
        If this is a range of ranges of simple ranges, return 3.
        '''
        depth = 1
        expr = self.body
        while isinstance(expr, ExprRange):
            depth += 1
            expr = expr.body
        return depth

    def _use_explicit_parameterization(self, format_type):
        '''
        Return True iff explicit parameterization should be used
        for the given format type given the 'style' settings.
        The default using 'explicit' for 'string' format and 'implicit'
        for 'latex' format.
        '''
        default_style = ("explicit" if format_type == 'string' else 'implicit')
        if (self.get_style("parameterization", default_style) == "explicit"):
            return True
        return False

    def _formatted_checkpoints(self, format_type, *,
                               use_explicit_parameterization=None,
                               ellipses=None, operator=None,
                               **kwargs):
        if use_explicit_parameterization is None:
            use_explicit_parameterization = (
                self._use_explicit_parameterization(format_type))
        check_points = [self.first(), self.last()]
        if use_explicit_parameterization and not self.is_parameter_independent:
            check_points.insert(1, self.body)
        formatted_sub_expressions = \
            [sub_expr.formatted(format_type, operator=operator,
                                **kwargs)
             for sub_expr in check_points]
        if self.is_parameter_independent:
            from proveit.numbers import one
            repeats_str = (r'\textrm{ repeats}' if format_type == 'latex'
                           else 'repeats')
            if self.start_index == one:
                formatted_sub_expressions.insert(
                    1, '%s %s' % (self.end_index.formatted(format_type),
                                  repeats_str))
            else:
                to_str = (r'\textrm{ to }' if format_type == 'latex' else 'to')
                from_str = (r'\textrm{from }' if format_type == 'latex'
                            else 'from')
                formatted_sub_expressions.insert(
                    1, ('%s %s %s %s'
                        % (from_str,
                           self.start_index.formatted(format_type), to_str,
                           self.end_index.formatted(format_type))))
        if ellipses is None:
            if use_explicit_parameterization or self.is_parameter_independent:
                # Use the format:
                # x_1, ..x_k.., x_n
                # Or for nested ExprRanges:
                # x_{1,1}, ..x_{1,k}.., x_{1,n},
                # ....x_{j,1}, ..x_{j,k}.., x_{j,n}....,
                # x_{m,1}, ..x_{m,k}.., x_{m,n}
                ellipsis = '..'
            else:
                ellipsis = ('\ldots' if format_type == 'latex'
                            else '...')
            # When ranges are nested, double-up (or triple-up, etc)
            # the ellipsis to make the nested structure clear.
            ellipses = ellipsis * self.nested_range_depth()
        if use_explicit_parameterization or self.is_parameter_independent:
            # e.g., ..x_k..
            formatted_sub_expressions[1] = \
                ellipses + formatted_sub_expressions[1] + ellipses
        else:
            # Insert the ellipses between the two "checkpoints".
            # e.g., x_1, ..., x_n
            formatted_sub_expressions.insert(1, ellipses)
        return formatted_sub_expressions

    def formatted(self, format_type, fence=False, sub_fence=True,
                  operator=None, **kwargs):
        if operator is None:
            # comma is the default formatted operator
            formatted_operator = ', '
        elif isinstance(operator, str):
            formatted_operator = operator
        else:
            formatted_operator = operator.formatted(format_type)
        formatted_sub_expressions = self._formatted_checkpoints(
            format_type, fence=sub_fence, with_ellipses=True,
            operator=operator)
        # Normally the range will be wrapped in an ExprTuple and
        # fencing will be handled externally.  When it isn't, we don't
        # want to fence it  anyway.
        return formatted_operator.join(formatted_sub_expressions)

    def get_instance(self, index, assumptions=USE_DEFAULTS,
                     requirements=None, equality_repl_requirements=None):
        '''
        Return the range instance with the given Lambda map
        index as an Expression, using the given assumptions as
        needed to interpret the index expression.  Required
        truths, proven under the given assumptions, that
        were used to make this interpretation will be
        appended to the given 'requirements' (if provided).
        '''
        from proveit.numbers import LessEq

        if requirements is None:
            # requirements won't be passed back in this case
            requirements = []

        # first make sure that the indices are in the range
        start_index, end_index = self.start_index, self.end_index
        for first, second in ((start_index, index), (index, end_index)):
            relation = None
            try:
                relation = LessEq.sort([first, second], reorder=False,
                                       assumptions=assumptions)
            except BaseException:
                raise RangeInstanceError(
                    "Indices not provably within the range "
                    "range: %s <= %s" % (first, second))
            requirements.append(relation)

        # map to the desired instance
        return self.lambda_map.apply(
            index, assumptions=assumptions, requirements=requirements,
            equality_repl_requirements=equality_repl_requirements)

    def _possibly_free_var_ranges(self, exclusions=None):
        '''
        Return the dictionary mapping Variables to forms w.r.t. ranges
        of indices (or solo) in which the variable occurs as free or
        not explicitly and completely masked.  Examples of "forms":
            x
            x_i
            x_1, ..., x_n
            x_{i, 1}, ..., x_{i, n_i}
            x_{1, 1}, ..., x_{1, n_1}, ......, x_{m, 1}, ..., x_{m, n_m}

        If this Expression is in the exclusion set, or contributes
        directly to a form that is in the exclusions set, skip over it.
        For example, given the expression
            a*x_{i, 1} + ... + a*x_{i, n_1}
        if x_{i, 1}, ..., x_{i, n_i} is in the exclusion set,
        then 'a' will be the only free variable reported.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var
        if exclusions is not None:
            if self in exclusions:
                return dict()  # this is excluded
            # For the body, extend the exclusion set as necessary to
            # exclude anything contributing directly to a form that is
            # in the exclusion set.  For example, if
            # x_1, ..., x_n is in the exclusion set and
            # self.parameter==k and self.start_index==1 and
            # self.end_index==n then add x_k to the exclusion set of
            # this body.
            body_exclusions = set(exclusions)
            for exclusion in exclusions:
                if (isinstance(exclusion, ExprRange) and
                        exclusion.start_index == self.start_index and
                        exclusion.end_index == self.end_index):
                    new_exclusion = exclusion.body.replaced(
                        {exclusion.parameter: self.parameter})
                    body_exclusions.add(new_exclusion)
        else:
            body_exclusions = None
        body_forms_dict = \
            self.body._possibly_free_var_ranges(exclusions=body_exclusions)
        # deep copy body_forms_dict into forms_dict
        forms_dict = {var: set(ranges) for var, ranges
                      in body_forms_dict.items()}
        param = self.parameter
        # Eliminate the parameter; it is not a free variable.
        if param in forms_dict.keys():
            forms_dict[param].discard(param)
            if len(forms_dict[param]) == 0:
                forms_dict.pop(param)
        for expr in self._sub_expressions[1:]:
            # Skip the first sub-expression. We've already treated that.
            for var, forms in expr._possibly_free_var_ranges(
                    exclusions=exclusions).items():
                forms_dict.setdefault(var, set()).update(forms)
        # The var ranges of the body that depend upon self.parameter
        # will be promoted to expression ranges over the range of this
        # ExprRange.  For example, if x_k is one of the var ranges of
        # the body and self.parameter==k, then x_k will be replaced
        # by x_1, ..., x_n.
        for parameterized_var_range in self._parameterized_var_ranges(
                body_forms_dict):
            var = get_param_var(parameterized_var_range)
            assert var in forms_dict
            forms_dict[var].remove(parameterized_var_range)
            forms_dict[var].add(ExprRange(param, parameterized_var_range,
                                          self.start_index, self.end_index))
        return forms_dict

    def _parameterized_var_ranges(self, body_forms_dict=None):
        '''
        Yield each of body._possibly_free_var_ranges() that involves the
        ExprRange parameter as a free variable.
        For example, for ((x_1 < x_{1+1}) and ... and (x_n < x_{n+1})),
        the following will be yielded if k is the ExprRange parameter:
            x_k, x_{k+1}.
        Another example:
            a*x_{1, 1} + ... + a*x_{1, n_1} + ......
                + a*x_{m, 1} + ... + a*x_{m, n_1}
        will give
            x_{i, 1}, ..., x_{i, n_i}
        if i is the ExprRange parameter.
        '''
        if body_forms_dict is None:
            body_forms_dict = self.body._possibly_free_var_ranges()
        param = self.parameter
        for var, forms in body_forms_dict.items():
            for form in forms:
                if form == self:
                    continue
                if form == self.parameter:
                    continue  # don't count the parameter itself.
                var_forms_of_form = form._possibly_free_var_ranges()
                if (param in var_forms_of_form
                        and param in var_forms_of_form[param]):
                    yield form

    def _possibly_reduced_range_entries(self, expr_range, assumptions,
                                        requirements):
        '''
        Yield the entries corresponding to the given expr_range after
        the possible reduction.  If there is no reduction, the
        'expr_range' itself is yielded.
        Note: this cannot be done via the regular 'auto_reduction'
        method because the reductions are of the form of reducing 'self'
        wrapped in an ExprTuple rather than 'self' itself.
        '''
        from proveit import Judgment
        from proveit import f, i, j, m, n
        from proveit.logic import Equals
        from proveit.numbers import Add, one
        if (not defaults.auto_reduce
                or ExprRange in defaults.disabled_auto_reduction_types):
            # Auto-reduction for this is disabled.
            yield expr_range
            return
        lambda_map = expr_range.lambda_map
        start_index = expr_range.start_index
        end_index = expr_range.end_index
        if start_index == end_index:
            # We can do a singular range reduction.
            # Temporarily disable automation to avoid infinite
            # recursion.
            from proveit.core_expr_types.tuples import \
                singular_range_reduction, singular_nested_range_reduction
            defaults.disabled_auto_reduction_types.add(ExprRange)
            try:
                if expr_range.nested_range_depth() > 1:
                    lambda_map = Lambda(
                        (expr_range.parameter,
                         expr_range.body.parameter),
                        expr_range.body.body)
                    reduction = singular_nested_range_reduction.instantiate(
                        {
                            f: lambda_map,
                            m: start_index,
                            i: expr_range.first().start_index,
                            j: expr_range.first().end_index},
                        assumptions=assumptions)
                else:
                    reduction = singular_range_reduction.instantiate(
                        {f: lambda_map, i: start_index},
                        assumptions=assumptions)
            finally:
                # Re-enable automation.
                defaults.disabled_auto_reduction_types.remove(ExprRange)
        else:
            # If the start and end are literal integers and form an
            # empty range, then it should be straightforward to
            # prove that the range is empty.
            from proveit.numbers import is_literal_int
            empty_req = Equals(Add(end_index, one), start_index)
            if is_literal_int(start_index) and is_literal_int(end_index):
                if end_index.as_int() + 1 == start_index.as_int():
                    empty_req.prove()
            if empty_req.proven(assumptions):
                # We can do an empty range reduction
                # Temporarily disable automation to avoid infinite
                # recursion.
                if expr_range.nested_range_depth() > 1:
                    # this is a nested range, but we know
                    # that the outer range reduces to an empty range,

                    # We can do an empty range reduction on the entire expression
                    # Temporarily disable automation to avoid infinite
                    # recursion.
                    from proveit.core_expr_types.tuples import \
                        empty_outside_range_of_range
                    defaults.disabled_auto_reduction_types.add(ExprRange)
                    try:
                        nest_end_index = expr_range.first().end_index
                        nest_start_index = expr_range.first().start_index
                        lambda_map = Lambda(
                            (expr_range.parameter, expr_range.body.parameter), expr_range.body.body)
                        reduction = empty_outside_range_of_range.instantiate(
                            {f: lambda_map, m: start_index, n: end_index, i: nest_start_index, j: nest_end_index},
                            assumptions=assumptions)
                    finally:
                        # Re-enable automation.
                        defaults.disabled_auto_reduction_types.remove(
                            ExprRange)
                else:
                    from proveit.core_expr_types.tuples import \
                        empty_range_def
                    defaults.disabled_auto_reduction_types.add(ExprRange)
                    try:
                        reduction = empty_range_def.instantiate(
                            {f: lambda_map, i: start_index, j: end_index},
                            assumptions=assumptions)
                    finally:
                        # Re-enable automation.
                        defaults.disabled_auto_reduction_types.remove(
                            ExprRange)
            elif expr_range.nested_range_depth() > 1:
                # this is a nested range so the inner range could be empty.

                # If the start and end of the inner range are literal
                # integers and form an empty range, then it should be
                # straightforward to prove that the entire range is empty.
                from proveit.numbers import is_literal_int
                empty_req = Equals(
                    Add(expr_range.first().end_index, one), expr_range.first().start_index)
                if is_literal_int(
                        expr_range.first().start_index) and is_literal_int(
                        expr_range.first().end_index):
                    if expr_range.first().end_index.as_int() + \
                            1 == expr_range.first().start_index.as_int():
                        empty_req.prove()
                if empty_req.proven(assumptions):
                    # We can do an empty range reduction on the entire expression
                    # Temporarily disable automation to avoid infinite
                    # recursion.
                    from proveit.core_expr_types.tuples import \
                        empty_inside_range_of_range
                    defaults.disabled_auto_reduction_types.add(ExprRange)
                    try:
                        nest_end_index = expr_range.first().end_index
                        nest_start_index = expr_range.first().start_index
                        lambda_map = Lambda(
                            (expr_range.parameter, expr_range.body.parameter), expr_range.body.body)
                        reduction = empty_inside_range_of_range.instantiate(
                            {f: lambda_map, m: start_index, n: end_index, i: nest_start_index, j: nest_end_index},
                            assumptions=assumptions)
                    finally:
                        # Re-enable automation.
                        defaults.disabled_auto_reduction_types.remove(
                            ExprRange)
                else:
                    yield expr_range  # no reduction
                    return

            else:
                yield expr_range  # no reduction
                return
        assert isinstance(reduction, Judgment)
        assert isinstance(reduction.expr, Equals)
        assert reduction.expr.operands.num_entries() == 2
        assert reduction.expr.operands[0] == ExprTuple(expr_range)
        reduced_tuple = reduction.expr.operands[1]
        assert isinstance(reduced_tuple, ExprTuple)
        requirements.append(reduction)
        for entry in reduced_tuple:
            yield entry

    def _replaced_entries(self, repl_map, allow_relabeling,
                          assumptions, requirements,
                          equality_repl_requirements):
        '''
        Returns this expression with sub-expressions replaced
        according to the replacement map (repl_map) dictionary.

        'assumptions' and 'requirements' are used when an operator is
        replaced by a Lambda map that has a range of parameters such
        that the length of the parameters and operands must be proven
        to be equal.  See the Operation.replaced and Lambda.apply
        documentation for more details.

        Expansion replacements of a range of indexed variables must
        be made explicit for the corresponding range (and therefore
        unambiguous and direct).  For example, to expand x in the
        following expression
            (x_1 < x_{1+1}) and ... and (x_n < x_{n+1})
        there must be a replacement in repl_map for
        (x_1, ..., x_n) as well as (x_{1+1}, ..., x_{n}).
        In an instantiation, this can be done by supplying
        instantiations of multiple forms of ranges of x.  For example:
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{1+1}, ..., d_{n+1})
        where the following requirements must be satisfied:
            (1, ..., n, n+1) = (1, ..., n+1)
            (1, 1+1, ..., n+1) = (1, ..., n+1)
            (a_1, ..., a_n, b) = (c, d_{1+1}, ..., d_{n+1})

        When multiple indexed variables are expanded within the
        ExprRange, the expansions must be in exact correspondence
        with respect to range start and index indices of the expansion.
        The above example meets this requirement since
            a_1, ..., a_n
            matches with
            b_{1+1}, ..., b_{n+1}
            by both being ranges from 1 to n.
        This expansion would fail this requirement
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{2}, ..., d_{n+1})
        since d_{2}, ..., d_{n+1} is a range from 2 to n+1.

        Here is another valid instantiation:
            (x_1, ..., x_n, x_{n+1}) :
                (a_1, ..., a_n, a_{n+1}, b_1, ..., b_n, b_{n+1})
            (x_1, x_{1+1}, ..., x_{n+1}) :
                (a_1, a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1})
        since
             a_1, ..., a_n, a_{n+1}, b_1, ..., b_n
             matches with
             a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1}
             with the pattern: 1 to n, single element, 1 to n.

        See the Lambda.apply documentation for a related discussion.
        '''
        from proveit._core_.expression.expr import attempt_to_simplify
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            get_param_var, extract_param_replacements
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.logic import Equals  # , InSet
        from proveit.numbers import Add, one  # , Interval

        if len(repl_map) > 0 and (self in repl_map):
            # The full expression is to be replaced.
            return repl_map[self]

        if requirements is None:
            requirements = []
        assumptions = defaults.checked_assumptions(assumptions)
        # We will turn on the `indices_must_match` flag when the
        # replacement index ranges must match the original range of
        # indices and not just match in length:
        indices_must_match = False
        # Stash anything we temporarily pop out of the repl_map.
        repl_map_stash = dict()

        # `var_range_forms` maps variables to the set of equivalent
        # forms of indexing over a range pertinent to getting the
        # replaced entries of this ExprRange.
        # Remove them from the `repl_map` temporarily.
        var_range_forms = dict()
        expanding_occurrences = set()
        parameterized_var_ranges = list(self._parameterized_var_ranges())
        for occurrence in parameterized_var_ranges:
            # `occurrence` may be something like x_k or
            # x_{k,1}, ..., x_{k,n}
            # where `k` is `self.parameter`.
            # If repl_map maps `x` to a set, in this example,
            # then it has an expansion for any of the forms that
            # are contained in the set.
            var = get_param_var(occurrence)
            if var in var_range_forms:
                expanding_occurrences.add(occurrence)
                # Already added this `var` to `var_expansion_forms` and
                # removed it from `repl_map`:
                continue
            repl = repl_map.get(var, None)
            if isinstance(repl, set):
                expanding_occurrences.add(occurrence)
                var_range_forms[var] = repl
                repl_map_stash[var] = repl_map.pop(var)
            elif not indices_must_match:
                # If some variables are expanded but others are not,
                # our replacement index ranges will need to match the
                # original range of indices to be a valid replacement.
                indices_must_match = True
                reason_indices_must_match = var  # temporary assignment
        if len(var_range_forms) > 0:
            expanding_var = next(iter(var_range_forms))
            if indices_must_match:
                # `reason_indices_must_match` was temporarily assigned
                # to a Variable that is not being expanded.  Change it
                # to a proper message now that we have a variable that
                # is being expanded.
                reason_indices_must_match = (
                    "not all of the indexed variables being indexed "
                    "by the ExprRange parameter are being expanded "
                    "(%s is expanded but %s is not)"
                    % (expanding_var, reason_indices_must_match))

        # Make all of the replacements except for the variables
        # being expanded.  If variables are to be expanded, this
        # result will be used for getting the start and end indices
        # ('starts' and 'ends').
        subbed_expr_range = self.replaced(
            repl_map, allow_relabeling, assumptions, requirements,
            equality_repl_requirements)
        if len(var_range_forms) == 0:
            # Nothing to expand.
            # However, we may perform a reduction of the range
            # if it is known to be empty or singular.
            for entry in self._possibly_reduced_range_entries(
                    subbed_expr_range, assumptions, requirements):
                yield entry
            return  # Done.

        # Need to handle the change in scope within the lambda
        # expression.
        # Note, we should have already gotten requirements
        # when calling self.replaced.
        dummy_reqs = []
        dummy_equality_repl_reqs = set()
        new_params, inner_repl_map, inner_assumptions \
            = self.lambda_map._inner_scope_sub(
                repl_map, allow_relabeling, assumptions,
                dummy_reqs, dummy_equality_repl_reqs)
        # Sanity check that we didn't introduce new requirements.
        # "_inner_scope_sub" should not introduce anything that
        # wasn't introduced when we called `self.replaced`.
        prev_reqs = set(requirements)
        for req in dummy_reqs:
            assert req in prev_reqs

        assert len(new_params) == 1
        new_param = new_params[0]
        safe_dummy_var = safe_dummy_var(self.body, self.parameter)
        # Restore the repl_map, adding back in what was temporarily
        # popped out.
        repl_map.update(repl_map_stash)

        # If the range parameter is used for anything other than an
        # index of an indexed variable, or not all of the
        # parameterized_var_ranges are expanded, all of the new indices
        # must match the original indices, not just the length.
        excluded_var_ranges = \
            self.body._possibly_free_var_ranges(
                exclusions=parameterized_var_ranges)
        if self.parameter in excluded_var_ranges:
            indices_must_match = True
            reason_indices_must_match = (
                "the ExprRange parameter appears outside of IndexedVar "
                "indices")

        # Create `expansions_dict` to map each of the variables being
        # expanded to the expansion that is relevent for this ExprRange.
        expansions_dict = dict()
        #orig_parameters = extract_parameters(self)
        #starts = extract_start_indices(subbed_expr_range)
        #ends = extract_end_indices(subbed_expr_range)
        orig_parameter = self.parameter
        subbed_start_index = subbed_expr_range.start_index
        subbed_end_index = subbed_expr_range.end_index
        #assert len(starts)==len(ends)==len(orig_parameters)
        for occurrence in expanding_occurrences:
            # We need to create a proper "variable range" with simple
            # parameterized indices.  Any shifts of the indices of
            # the indexed_var_or_range must be absorbed into the
            # starting/ending indices.  For example
            # x_{k+1} with k going from 1 to n should change to
            # x_k with k going from 1+1 to n+1.
            indexed_var = innermost_body(occurrence)
            var_indices = indexed_var.indices
            var = indexed_var.var

            param_index = None

            # Note: We'll make replacements of IndexedVar indices and start
            # and end range indices of the occurrence, but not the variable
            # itself, before we look up the replacement for the corresponding
            # variable range.
            occurrence_map = dict(repl_map)
            occurrence_map.pop(var)
            for idx in var_indices:
                if orig_parameter in free_vars(idx, err_inclusively=True):
                    if param_index is not None:
                        raise ImproperReplacement(
                            self, repl_map,
                            "Failure to expand %s because %s is not a valid "
                            "occurrence with the range parameter %s; multiple "
                            "index occurrences are not allowed."
                            % (self, occurrence, orig_parameter))
                    start_with_absorbed_shift = \
                        idx.replaced({orig_parameter: subbed_start_index})
                    end_with_absorbed_shift = \
                        idx.replaced({orig_parameter: subbed_end_index})
                    param_index = idx
                    occurrence_map[idx] = orig_parameter
                    if idx != orig_parameter:
                        # We'll map the original parameter to a safe dummy var
                        # so we can detect if there are other instances of
                        # the original parameter with a different shift.
                        occurrence_map[orig_parameter] = safe_dummy_var
            if param_index is None:
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s is not a valid "
                    "occurrence with the range parameter %s; not used as "
                    "an index."
                    % (self, occurrence, orig_parameter))
            orig_occurrence = occurrence
            occurrence = occurrence.replaced(
                occurrence_map, allow_relabeling, assumptions, requirements,
                equality_repl_requirements)
            if safe_dummy_var in free_vars(occurrence, err_inclusively=True):
                # There was an instance of the original parameter with a
                # different shift than what we used.  That's not allowed.
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because %s does not use a "
                    "consistent shift the range parameter %s."
                    % (self, orig_occurrence, orig_parameter))

            var_range = ExprRange(orig_parameter, occurrence,
                                  start_with_absorbed_shift,
                                  end_with_absorbed_shift)

            # Now wrap this "variable range" in an ExprTuple and see
            # if it has a known expansion.
            var_tuple = ExprTuple(var_range)
            var = get_param_var(occurrence)
            if var_tuple not in inner_repl_map:
                def key_var(key): return (get_param_var(key[0]) if
                                          isinstance(key, ExprTuple)
                                          else get_param_var(key))
                var_replacements = \
                    {key: value for key, value in inner_repl_map.items() if
                     key_var(key) == var}
                print('problem self', self, repl_map)
                raise ImproperReplacement(
                    self, repl_map,
                    "Failure to expand %s because there is no explicit "
                    "expansion for %s.  The known expansions for "
                    "this variable are %s.  "
                    "(Note that multiple, equivalent expansion forms "
                    "may be provided to fulfill this requirement)."
                    % (self, var_tuple, var_replacements))
            repl = inner_repl_map.pop(var_tuple)
            if not isinstance(repl, ExprTuple):
                raise ImproperReplacement(
                    self, repl_map,
                    "Invalid replacement %s for %s; it must be an "
                    "ExprTuple." % (var_tuple, repl))
            expansions_dict[occurrence] = repl.entries

        def raise_failed_expansion_match(first_expansion, expansion,
                                         first_indexed_var_or_range,
                                         indexed_var_or_range):
            raise ImproperReplacement(
                self, repl_map,
                "When expanding IndexedVar's within an ExprRange whose "
                "parameter is the index, their expansion ExprRange "
                "indices must all match. %s vs %s do not match as "
                "respected expansions for %s and %s."
                % (first_expansion, expansion,
                   first_indexed_var_or_range, indexed_var_or_range))

        # Do we need to match the new indices to the original indices?
        if indices_must_match:
            # Yes.  Prepare to do that.
            new_indices = []
            next_index = subbed_start_index

        # Divy up the expansions into aligned entries, each with
        # its own replacement map.  This is in preparation to yield
        # a replaced version of the body for each of these entries.
        # Each entry is either singular (at this level) or an ExprRange
        # (where we will yield a new ExprRange covering a portion of
        # the original ExprRange).  The "alignment" of the entries
        # means that corresponding ExprRange entries must have the
        # same start and end indices (i.e., for different expansions).
        body = self.body
        entry_repl_maps = None
        # This will be a list with only the ExprRange entries and None
        # for non-ExprRange entries.
        first_expansion_entry_ranges = None
        for indexed_var_or_range, expansion in expansions_dict.items():
            parameters = [indexed_var_or_range]
            parameter_vars = [get_param_var(indexed_var_or_range)]
            expansion_iter = iter(expansion)
            # Replacement maps corresponding with this
            # 'indexed_var_or_range' and 'expansion'.
            expansion_repl_maps = []
            expansion_entry_ranges = []
            while True:
                entry_repl_map = dict()
                # Peek ahead; get the next entry without advancing the
                # iter.
                head, expansion_iter = more_itertools.spy(expansion_iter)
                if len(head) == 0:
                    break  # No more entries.
                # See if the next entry is to be a proper ExprRange
                # entry at this level.
                entry = head[0]
                if (isinstance(entry, ExprRange) and
                        is_at_same_nested_range_level(indexed_var_or_range,
                                                      entry.body)):
                    # This is a proper ExprRange entry (at this level).
                    # The replacement map will map
                    # 'indexed_var_or_range' to the body of the entry
                    # with the parameter changed to our 'new_param'.
                    param_repl_map = {entry.parameter: new_param}
                    new_body = entry.body.replaced(param_repl_map)
                    entry_repl_map[indexed_var_or_range.replaced(
                        param_repl_map)] = new_body
                    expansion_entry_ranges.append(entry)
                    # Advance the "expansion iter".
                    next(expansion_iter)
                else:
                    # This is not a proper ExprRange entry.  It may
                    # be a simple singular entry, or multiple entries
                    # for a nested ExprRange (which is why we need
                    # to use the 'extract_param_replacements' method).
                    extract_param_replacements(
                        parameters, parameter_vars, body,
                        expansion_iter, assumptions, requirements,
                        entry_repl_map)
                    # Mark as a non-ExprRange entry by simply appending
                    # None.
                    expansion_entry_ranges.append(None)
                expansion_repl_maps.append(entry_repl_map)
            if first_expansion_entry_ranges is None:
                # This is the first expansion we are processing.
                entry_repl_maps = expansion_repl_maps
                first_expansion_entry_ranges = expansion_entry_ranges
                first_expansion = expansion
                first_indexed_var_or_range = indexed_var_or_range
            else:
                # We have processed other expansions.  Make sure
                # they are consistent w.r.t. ExprRange entries
                # and total number of entries.
                if len(first_expansion_entry_ranges) != len(
                        expansion_entry_ranges):
                    # Failing to have the same number of entries.
                    raise_failed_expansion_match(
                        first_expansion, expansion,
                        first_indexed_var_or_range,
                        indexed_var_or_range)
                for first_expansion_entry, expansion_entry in zip(
                        first_expansion_entry_ranges, expansion_entry_ranges):
                    if (isinstance(expansion_entry, ExprRange)
                            != isinstance(first_expansion_entry, ExprRange)):
                        # Failing to match w.r.t. being an ExprRange
                        # entry or not.
                        raise_failed_expansion_match(
                            first_expansion, expansion,
                            first_indexed_var_or_range,
                            indexed_var_or_range)
                    if isinstance(expansion_entry, ExprRange):
                        if (expansion_entry.start_index
                                != first_expansion_entry.start_index):
                            # Failed to have the same ExprRange range
                            # (different start).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                        if (expansion_entry.end_index !=
                                first_expansion_entry.end_index):
                            # Failed to have the same ExprRange range
                            # (different end).
                            raise_failed_expansion_match(
                                first_expansion, expansion,
                                first_indexed_var_or_range,
                                indexed_var_or_range)
                # Combine the 'expansion_repl_maps' into the
                # 'entry_repl_maps' for all expansions.
                for entry_repl_map, expansion_repl_map in zip(
                        entry_repl_maps, expansion_repl_maps):
                    entry_repl_map.update(expansion_repl_map)

        def update_map(orig_repl_map, update):
            '''
            Given an original replacement map, use the 'update' dictionary
            to make replacements in all of its keys and values and then
            add the update entrie(s).
            '''
            new_repl_map = dict()
            for key, val in orig_repl_map.items():
                key = key.replaced(update)
                if isinstance(val, set):
                    val = {elem.replaced(update) for elem in val}
                else:
                    val = val.replaced(update)
                new_repl_map[key] = val
            new_repl_map.update(update)
            return new_repl_map

        # Yield a replacement for each of the aligned entry of the
        # expansions.  May be a singular entry or an ExprRange entry
        # representing a portion of the original range.
        for first_expansion_entry_range_or_none, entry_repl_map in zip(
                first_expansion_entry_ranges, entry_repl_maps):
            # Use the 'inner replacement map' updated with the
            # 'entry replacement map' to get the 'full entry replacment
            # map'.
            full_entry_repl_map = dict(inner_repl_map)
            full_entry_repl_map.update(entry_repl_map)
            # Now yield the substitution corresponding to this entry.
            if first_expansion_entry_range_or_none is not None:
                assert isinstance(first_expansion_entry_range_or_none,
                                  ExprRange)
                # For an ExprRange entry, yield a new ExprRange
                # representing a portion of th eoriginal range.
                first_expansion_entry = first_expansion_entry_range_or_none
                start_index = first_expansion_entry.start_index
                end_index = first_expansion_entry.end_index

                # Let's keep this simple and not worry about this
                # "range assumptions".
                # If needed, we can use explicit axioms/theorems to
                # make use of this property rather than in the core.
                # If we change our minds, the range assumption should
                # also be employed in the ExprRange._replaced method.
                # range_assumption = InSet(new_param,
                #                         Interval(start_index, end_index))

                entry_assumptions = inner_assumptions  # + [range_assumption]
                param_repl_map = {orig_parameter: new_param}
                full_entry_repl_map = update_map(
                    full_entry_repl_map, param_repl_map)
                entry = ExprRange(new_param,
                                  body.replaced(full_entry_repl_map,
                                                allow_relabeling,
                                                entry_assumptions,
                                                requirements,
                                                equality_repl_requirements),
                                  start_index, end_index)
                # We may perform a reduction of the range if it is known
                # to be empty or singular.
                for entry in self._possibly_reduced_range_entries(
                        entry, assumptions, requirements):
                    yield entry
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(ExprRange(new_param, new_param,
                                                 start_index, end_index))
                    next_index = Add(end_index, one)
            else:
                # For a singular element entry, yield the replaced
                # element.
                if indices_must_match:
                    # Attempt to simplify the 'next_index' only when
                    # we need it.
                    next_index = attempt_to_simplify(
                        next_index, assumptions, requirements)
                    # The actual range parameter index is needed:
                    param_repl_map = {orig_parameter: next_index}
                    full_entry_repl_map = update_map(
                        full_entry_repl_map, param_repl_map)
                    #full_entry_repl_map[orig_parameter] = next_index

                if isinstance(body, ExprRange):
                    # A nested ExprRange may need to be expanded.
                    for subentry in body._replaced_entries(
                            full_entry_repl_map, allow_relabeling,
                            inner_assumptions, requirements,
                            equality_repl_requirements):
                        yield subentry
                else:
                    yield body.replaced(full_entry_repl_map, allow_relabeling,
                                        inner_assumptions, requirements,
                                        equality_repl_requirements)

                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(next_index)
                    next_index = Add(next_index, one)

        if indices_must_match:
            # The range parameter appears outside of
            # IndexedVars.  That means that we must match new
            # and original indices precisely, not just their length.
            requirement = Equals(ExprTuple(*new_indices),
                                 ExprTuple(ExprRange(new_param, new_param,
                                                     subbed_start_index,
                                                     subbed_end_index)))
            if requirement.lhs == requirement.rhs:
                # No need for the requirement if it is a trivial
                # reflexive identity.
                return
            try:
                requirements.append(requirement.prove(assumptions))
            except ProofFailure as e:
                raise ImproperReplacement(
                    self, repl_map,
                    "ExprRange indices failed to match expansion "
                    "which is necessary because %s: %s."
                    % (reason_indices_must_match, e))

    def parameters(self):
        '''
        Return a list of parameters, one for each nested
        ExprRange.
        '''
        return extract_parameters(self)

    def innermost_body(self):
        '''
        Return the innermost body of a nested ExprRange.
        '''
        return innermost_body(self)

    def start_indices(self):
        '''
        Return a list of starting indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has start indices (m, i_m).
        '''
        return extract_start_indices(self)

    def end_indices(self):
        '''
        Return a list of ending indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has end indices (n, j_n).
        '''
        return extract_end_indices(self)

    def mapped_range(self, body_map_fn):
        '''
        Generate an ExprRange with the same external structure
        as this range but converts the innermost by applying the
        'body_map_fn' to it.
        '''
        inner_body = self.innermost_body(self)
        new_inner_body = body_map_fn(inner_body)
        parameters = extract_parameters(self)
        start_indices = extract_start_indices(self)
        end_indices = extract_end_indices(self)
        return nested_range(parameters, new_inner_body, start_indices,
                            end_indices)

    def partition(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a split version in the following manner:
            (f(self.start_index), ..., f(self.end_index)) =
            (f(self.start_index), ..., f(before_split_index),
             f(before_split_index+1), ..., f(self.end_index))
        where f represents the self.lambda_map.
        '''
        from proveit import f, i, j, k
        from proveit.logic import Equals
        from proveit.numbers import Add, one, subtract
        from proveit.core_expr_types.tuples import (
            range_extension_def)
        from proveit.core_expr_types.tuples import (
            partition_front, partition_back, partition)

        lambda_map = self.lambda_map
        start_index, end_index = self.start_index, self.end_index
        if end_index == Add(before_split_idx, one):
            # special case which uses the axiom:
            return range_extension_def.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx},
                assumptions=assumptions)
        elif before_split_idx == self.start_index:
            # special case when peeling off the front
            return partition_front.instantiate(
                {f: lambda_map, i: self.start_index, j: self.end_index},
                assumptions=assumptions)
        elif (before_split_idx == subtract(end_index, one) or
              Equals(before_split_idx, subtract(end_index, one)).proven(assumptions)):
            # special case when peeling off the back
            return partition_back.instantiate(
                {f: lambda_map, i: start_index, j: end_index},
                assumptions=assumptions)
        else:
            return partition.instantiate(
                {f: lambda_map, i: start_index, j: before_split_idx,
                 k: end_index}, assumptions=assumptions)

    def shift_equivalence(self, *, old_shift=None, new_start=None,
                          new_end=None, new_shift=None,
                          assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a shifted version in the following manner:
            (f(self.start_index+old_shift), ..., f(self.end_index+old_shift)) =
            (f(new_start+new_shift), ..., f(new_start+new_shift))
        where f is adapted from self.lambda_map according to 'old_shift'.
        If any of the 'new' parameters are unspecified, we attempt
        to deduce them from the other parameters.
        '''
        from proveit import a, b, f, i, j, k, l
        from proveit.numbers import Add, Neg, subtract
        from proveit._core_.expression.label.var import safe_dummy_var
        from proveit.core_expr_types.tuples import (
            shift_equivalence, shift_equivalence_both)

        if old_shift is None:
            _f = self.lambda_map
        else:
            old_shifted_param = Add(self.parameter, old_shift)
            safe_var = safe_dummy_var(self.body)
            shifted_body = self.body.replaced({old_shifted_param: safe_var})
            if self.parameter in free_vars(shifted_body, err_inclusively=True):
                raise ValueError("The given 'old_shift' of %s does apply "
                                 "to %s" % (old_shift, self.lambda_map))
            _f = Lambda(self.parameter,
                        shifted_body.replaced({safe_var: self.parameter}))

        _i, _j = self.start_index, self.end_index

        if new_shift is not None:
            net_shift = new_shift
            if old_shift is not None:
                net_shift = subtract(new_shift, old_shift).simplified(
                    assumptions=assumptions)
            if new_start is None:
                # new start = _i - new_shift
                new_start = subtract(_i, net_shift).simplified(
                    assumptions=assumptions)
            if new_end is None:
                # new_end = _j - new_shift
                new_end = subtract(_j, net_shift).simplified(
                    assumptions=assumptions)
        elif new_start is None:
            # new_start = new_end + i - j
            new_end = Add(new_start, _i, Neg(_j)).simplified(
                assumptions=assumptions)
        elif new_end is None:
            # new_end = new_start + j - i
            new_end = Add(new_start, _j, Neg(_i)).simplified(
                assumptions=assumptions)

        _k, _l = new_start, new_end

        if new_shift is None:
            # Compute the new shift based upon the other parameters.
            if old_shift is None:
                new_shift = subtract(
                    _i, _k).simplified(
                    assumptions=assumptions)
            else:
                new_shift = Add(_i, old_shift, Neg(_k)).simplified(
                    assumptions=assumptions)

        if old_shift is None:
            return shift_equivalence.instantiate(
                {f: _f, a: new_shift, i: _i, j: _j, k: _k, l: _l},
                assumptions=assumptions)
        else:
            return shift_equivalence_both.instantiate(
                {f: _f, a: old_shift, b: new_shift, i: _i, j: _j, k: _k, l: _l},
                assumptions=assumptions)

    """
    def _var_index_shifts_in_ranges(self, var, shifts):
        '''
        Given a 'var' (e.g., 'x'), pass back, via the set 'shifts',
        all of the constant indexed shifts to the ExprRange parameter
        within ExprRanges (e.g., 'x_{1+1}, ..., x_{n+1}' would have
        presumably have a shift of 1).
        '''
        self.body._indexed_var_shifts(var, self.parameter, shifts)
        Expression._var_index_shifts_in_ranges(self, var, shifts)
    """

    """
    TODO: change register_equivalence_method to allow and fascilitate these
    method stubs for purposes of generating useful documentation.

    def partitioned(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the right-hand-side of a 'partition'.
        '''
        raise Exception("Should be implemented via InnerExpr.register_equivalence_method")

    def split(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        As an InnerExpr method when the inner expression is an ExprRange,
        return the expression with the inner expression replaced by its
        'partitioned' version.
        '''
        raise Exception("Implemented via InnerExpr.register_equivalence_method "
                        "only to be applied to an InnerExpr object.")
    """


def _has_expansion(var_form, repl_map):
    '''
    Return True if and only if the given IndexedVar has
    an expansion in the given replacement map.
    '''
    from proveit._core_.expression.lambda_expr.lambda_expr import \
        get_param_var
    var_repl = repl_map.get(get_param_var(var_form), None)
    # When being expanded, a set of equivalent tuples of
    # indexed variables is used as the direct variable
    # replacement (e.g. x : {(x_1, ..., x_{n+1}),
    #                        (x_1, ..., x_n, x_{n+1})}).
    return isinstance(var_repl, set)


def extract_start_indices(expr_range):
    '''
    Return a list of starting indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has start indices (m, i_m).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        start_index = expr.start_index
        subbed_index = start_index.replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_end_indices(expr_range):
    '''
    Return a list of ending indices, one for each nested
    ExprRange.  For example,
        (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
         x_{n, i_{n}}, ..., x_{n, j_{n}}).
    has end indices (n, j_n).
    '''
    indices = []
    expr = expr_range
    repl_map = dict()
    while isinstance(expr, ExprRange):
        end_index = expr.end_index
        subbed_index = end_index.replaced(repl_map)
        indices.append(subbed_index)
        repl_map[expr.parameter] = subbed_index
        expr = expr.body
    return indices


def extract_parameters(expr_range):
    '''
    Return a list of parameters, one for each nested
    ExprRange.
    '''
    parameters = []
    expr = expr_range
    while isinstance(expr, ExprRange):
        parameters.append(expr.parameter)
        expr = expr.body
    return parameters


def innermost_body(expr_range):
    '''
    Return the innermost body of a nested ExprRange.
    '''
    expr = expr_range
    while isinstance(expr, ExprRange):
        expr = expr.body
    return expr


def is_at_same_nested_range_level(expr1, expr2):
    '''
    Return True iff 'expr1' and 'expr2' are either both
    ExprRanges, or nested ExprRanges at the same number of levels.
    '''
    while True:
        if isinstance(expr1, ExprRange) != isinstance(expr2, ExprRange):
            # Levels don't match.
            return False
        if not isinstance(expr1, ExprRange):
            # Made it to the end without encountering a mismatch.
            return True
        # Go another level deeper.
        expr1 = expr1.body
        expr2 = expr2.body


def nested_range(parameters, body, start_indices, end_indices):
    if len(parameters) > 1:
        # multiple levels
        return ExprRange(parameters[0],
                         nested_range(parameters[1:], body,
                                      start_indices[1:], end_indices[1:]),
                         start_indices[0], end_indices[0])
    else:
        # single level
        param = parameters[0]
        start_index, end_index = (start_indices[0],
                                  end_indices[0])
        return ExprRange(param, body, start_index, end_index)


def var_range(var, start_index_or_indices, end_index_or_indices):
    from proveit import (safe_dummy_vars, composite_expression,
                         IndexedVar)
    start_indices = composite_expression(start_index_or_indices)
    end_indices = composite_expression(end_index_or_indices)
    parameters = safe_dummy_vars(start_indices.num_entries(), var, 
                                 start_indices, end_indices)
    return nested_range(parameters, IndexedVar(var, parameters),
                        start_indices, end_indices)


class RangeInstanceError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg
