
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Equals &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="EvaluationError" href="proveit.logic.EvaluationError.html" />
    <link rel="prev" title="Distinct" href="proveit.logic.Distinct.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="equals">
<h1>Equals<a class="headerlink" href="#equals" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="proveit.logic.Equals">
<em class="property">class </em><code class="descclassname">proveit.logic.</code><code class="descname">Equals</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="proveit.TransitiveRelation.html#proveit.TransitiveRelation" title="proveit.relation.transitivity.TransitiveRelation"><code class="docutils literal notranslate"><span class="pre">proveit.TransitiveRelation</span></code></a></p>
<p class="rubric">Attributes Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.initializing" title="proveit.logic.Equals.initializing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initializing</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.inversions" title="proveit.logic.Equals.inversions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inversions</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.knownEqualities" title="proveit.logic.Equals.knownEqualities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">knownEqualities</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.known_evaluation_sets" title="proveit.logic.Equals.known_evaluation_sets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">known_evaluation_sets</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.known_simplifications" title="proveit.logic.Equals.known_simplifications"><code class="xref py py-obj docutils literal notranslate"><span class="pre">known_simplifications</span></code></a></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.StrongRelationClass" title="proveit.logic.Equals.StrongRelationClass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StrongRelationClass</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.WeakRelationClass" title="proveit.logic.Equals.WeakRelationClass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WeakRelationClass</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.affirmViaContradiction" title="proveit.logic.Equals.affirmViaContradiction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">affirmViaContradiction</span></code></a>(conclusion[,&nbsp;assumptions])</td>
<td>From (A=FALSE), derive the conclusion provided that the negated conclusion implies both (A=FALSE) as well as A, and the conclusion is a Boolean.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.applyTransitivity" title="proveit.logic.Equals.applyTransitivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applyTransitivity</span></code></a>(other[,&nbsp;assumptions])</td>
<td>From x = y (self) and y = z (other) derive and return x = z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.conclude" title="proveit.logic.Equals.conclude"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conclude</span></code></a>(assumptions)</td>
<td>Attempt to conclude the equality various ways: simple reflexivity (x=x), via an evaluation (if one side is an irreducible), or via transitivity.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.concludeBooleanEquality" title="proveit.logic.Equals.concludeBooleanEquality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concludeBooleanEquality</span></code></a>([assumptions])</td>
<td>Prove and return self of the form (A=TRUE) assuming A, A=FALSE assuming Not(A), [Not(A)=FALSE] assuming A.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.concludeViaReflexivity" title="proveit.logic.Equals.concludeViaReflexivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concludeViaReflexivity</span></code></a>([assumptions])</td>
<td>Prove and return self of the form x = x.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.deduceInBool" title="proveit.logic.Equals.deduceInBool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deduceInBool</span></code></a>([assumptions])</td>
<td>Deduce and return that this equality statement is in the set of Booleans.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.deduceNegated" title="proveit.logic.Equals.deduceNegated"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deduceNegated</span></code></a>(i[,&nbsp;assumptions])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.deduceNotEquals" title="proveit.logic.Equals.deduceNotEquals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deduceNotEquals</span></code></a>([assumptions])</td>
<td>Deduce x != y assuming not(x = y), where self is x=y.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.denyViaContradiction" title="proveit.logic.Equals.denyViaContradiction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denyViaContradiction</span></code></a>(conclusion[,&nbsp;assumptions])</td>
<td>From (A=FALSE), derive the negated conclusion provided that the conclusion implies both (A=FALSE) as well as A, and the conclusion is a Boolean.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.deriveContradiction" title="proveit.logic.Equals.deriveContradiction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveContradiction</span></code></a>([assumptions])</td>
<td>From A=FALSE, and assuming A, derive FALSE.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.deriveIsInSingleton" title="proveit.logic.Equals.deriveIsInSingleton"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveIsInSingleton</span></code></a>([assumptions])</td>
<td>From (x = y), derive (x in {y}).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.deriveLeftViaEquivalence" title="proveit.logic.Equals.deriveLeftViaEquivalence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveLeftViaEquivalence</span></code></a>([assumptions])</td>
<td>From A = B, derive A (the Right-Hand-Side) assuming B.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.deriveReversed" title="proveit.logic.Equals.deriveReversed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveReversed</span></code></a>([assumptions])</td>
<td>From x = y derive y = x.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.deriveRightViaEquivalence" title="proveit.logic.Equals.deriveRightViaEquivalence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveRightViaEquivalence</span></code></a>([assumptions])</td>
<td>From A = B, derive B (the Right-Hand-Side) assuming A.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.deriveViaBooleanEquality" title="proveit.logic.Equals.deriveViaBooleanEquality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deriveViaBooleanEquality</span></code></a>([assumptions])</td>
<td>From A = TRUE derive A, or from A = FALSE derive Not(A).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.evaluation" title="proveit.logic.Equals.evaluation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluation</span></code></a>([assumptions,&nbsp;automation])</td>
<td>Given operands that may be evaluated to irreducible values that may be compared, or if there is a known evaluation of this equality, derive and return this expression equated to TRUE or FALSE.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.invert" title="proveit.logic.Equals.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>(lambda_map,&nbsp;rhs[,&nbsp;assumptions])</td>
<td>Given some x -&gt; f(x) map and a right-hand-side, find the x for which f(x) = rhs amongst known equalities under the given assumptions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.knownRelationsFromLeft" title="proveit.logic.Equals.knownRelationsFromLeft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">knownRelationsFromLeft</span></code></a>(assumptionsSet)</td>
<td>For each KnownTruth that is an Equals involving the given expression on the left hand side, yield the KnownTruth and the right hand side.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.knownRelationsFromRight" title="proveit.logic.Equals.knownRelationsFromRight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">knownRelationsFromRight</span></code></a>(expr,&nbsp;assumptionsSet)</td>
<td>For each KnownTruth that is an Equals involving the given expression on the right hand side, yield the KnownTruth and the left hand side.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.negationSideEffects" title="proveit.logic.Equals.negationSideEffects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">negationSideEffects</span></code></a>(knownTruth)</td>
<td>Side-effect derivations to attempt automatically for a negated equation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.otherSide" title="proveit.logic.Equals.otherSide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">otherSide</span></code></a>(expr)</td>
<td>Returns the ‘other’ side of the of the equation if the given expr is on one side.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.reversed" title="proveit.logic.Equals.reversed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reversed</span></code></a>()</td>
<td>Return an Equals expression with the right side and left side reversed from this one.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.sideEffects" title="proveit.logic.Equals.sideEffects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sideEffects</span></code></a>(knownTruth)</td>
<td>Record the knownTruth in Equals.knownEqualities, associated from the left hand side and the right hand side.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.subLeftSideInto" title="proveit.logic.Equals.subLeftSideInto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subLeftSideInto</span></code></a>(lambda_map[,&nbsp;assumptions])</td>
<td>From x = y, and given P(y), derive P(x) assuming P(y).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#proveit.logic.Equals.subRightSideInto" title="proveit.logic.Equals.subRightSideInto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subRightSideInto</span></code></a>(lambda_map[,&nbsp;assumptions])</td>
<td>From x = y, and given P(x), derive P(y) assuming P(x).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#proveit.logic.Equals.substitution" title="proveit.logic.Equals.substitution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">substitution</span></code></a>(lambda_map[,&nbsp;assumptions])</td>
<td>From x = y, and given f(x), derive f(x)=f(y).</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="attribute">
<dt id="proveit.logic.Equals.initializing">
<code class="descname">initializing</code><em class="property"> = set()</em><a class="headerlink" href="#proveit.logic.Equals.initializing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="proveit.logic.Equals.inversions">
<code class="descname">inversions</code><em class="property"> = {}</em><a class="headerlink" href="#proveit.logic.Equals.inversions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="proveit.logic.Equals.knownEqualities">
<code class="descname">knownEqualities</code><em class="property"> = {TRUE: {|- [not](TRUE = FALSE) = TRUE, |- [not]([not](TRUE) = TRUE) = TRUE, |- TRUE = [not](FALSE = TRUE), |- TRUE = [not]([not](TRUE)), |- TRUE = TRUE, |- TRUE = [not](TRUE = FALSE), |- [not](FALSE) = TRUE, |- [not]([not](TRUE)) = TRUE, |- TRUE = [not]([not](TRUE) = TRUE), |- [not](TRUE = [not](TRUE)) = TRUE, |- TRUE = [not](FALSE), |- TRUE = [not](TRUE = [not](TRUE)), |- [not](FALSE = TRUE) = TRUE}, TRUE = FALSE: {|- FALSE = (TRUE = FALSE), |- (TRUE = FALSE) = FALSE}, FALSE: {|- (FALSE = TRUE) = FALSE, |- FALSE = FALSE, |- FALSE = (FALSE = TRUE), |- FALSE = (TRUE = FALSE), |- (TRUE = [not](TRUE)) = FALSE, |- FALSE = ([not](TRUE) = TRUE), |- [not](TRUE) = FALSE, |- FALSE = (TRUE = [not](TRUE)), |- ([not](TRUE) = TRUE) = FALSE, |- (TRUE = FALSE) = FALSE, |- FALSE = [not](TRUE)}, [not](TRUE = FALSE): {|- [not](TRUE = FALSE) = TRUE, |- TRUE = [not](TRUE = FALSE)}, FALSE = TRUE: {|- FALSE = (FALSE = TRUE), |- (FALSE = TRUE) = FALSE}, [not](FALSE = TRUE): {|- [not](FALSE = TRUE) = TRUE, |- TRUE = [not](FALSE = TRUE)}, [not](FALSE): {|- TRUE = [not](FALSE), |- [not](FALSE) = TRUE}, [not](TRUE): {|- FALSE = [not](TRUE), |- [not](TRUE) = FALSE}, TRUE = [not](TRUE): {|- FALSE = (TRUE = [not](TRUE)), |- (TRUE = [not](TRUE)) = FALSE}, [not](TRUE = [not](TRUE)): {|- [not](TRUE = [not](TRUE)) = TRUE, |- TRUE = [not](TRUE = [not](TRUE))}, [not](TRUE) = TRUE: {|- FALSE = ([not](TRUE) = TRUE), |- ([not](TRUE) = TRUE) = FALSE}, [not]([not](TRUE) = TRUE): {|- TRUE = [not]([not](TRUE) = TRUE), |- [not]([not](TRUE) = TRUE) = TRUE}, [not]([not](TRUE)): {|- TRUE = [not]([not](TRUE)), |- [not]([not](TRUE)) = TRUE}, BOOLEANS: {|- {TRUE, FALSE} = BOOLEANS, |- BOOLEANS = {TRUE, FALSE}}, {TRUE, FALSE}: {|- {TRUE, FALSE} = BOOLEANS, |- BOOLEANS = {TRUE, FALSE}}, -0: {|- (-0) = 0, |- 0 = (-0)}, 0: {|- (-0) = 0, |- 0 = (-0)}}</em><a class="headerlink" href="#proveit.logic.Equals.knownEqualities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="proveit.logic.Equals.known_evaluation_sets">
<code class="descname">known_evaluation_sets</code><em class="property"> = {TRUE: {|- TRUE = TRUE}, TRUE = FALSE: {|- (TRUE = FALSE) = FALSE}, [not](TRUE = FALSE): {|- [not](TRUE = FALSE) = TRUE}, FALSE = TRUE: {|- (FALSE = TRUE) = FALSE}, [not](FALSE = TRUE): {|- [not](FALSE = TRUE) = TRUE}, [not](FALSE): {|- [not](FALSE) = TRUE}, [not](TRUE): {|- [not](TRUE) = FALSE}, TRUE = [not](TRUE): {|- (TRUE = [not](TRUE)) = FALSE}, [not](TRUE = [not](TRUE)): {|- [not](TRUE = [not](TRUE)) = TRUE}, [not](TRUE) = TRUE: {|- ([not](TRUE) = TRUE) = FALSE}, [not]([not](TRUE) = TRUE): {|- [not]([not](TRUE) = TRUE) = TRUE}, [not]([not](TRUE)): {|- [not]([not](TRUE)) = TRUE}, FALSE: {|- FALSE = FALSE}, -0: {|- (-0) = 0}}</em><a class="headerlink" href="#proveit.logic.Equals.known_evaluation_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="proveit.logic.Equals.known_simplifications">
<code class="descname">known_simplifications</code><em class="property"> = {(TRUE, ()): |- TRUE = TRUE, (TRUE = FALSE, ()): |- (TRUE = FALSE) = FALSE, ([not](TRUE = FALSE), ()): |- [not](TRUE = FALSE) = TRUE, (FALSE = TRUE, ()): |- (FALSE = TRUE) = FALSE, ([not](FALSE = TRUE), ()): |- [not](FALSE = TRUE) = TRUE, ([not](FALSE), ()): |- [not](FALSE) = TRUE, ([not](TRUE), ()): |- [not](TRUE) = FALSE, (TRUE = [not](TRUE), ()): |- (TRUE = [not](TRUE)) = FALSE, ([not](TRUE = [not](TRUE)), ()): |- [not](TRUE = [not](TRUE)) = TRUE, ([not](TRUE) = TRUE, ()): |- ([not](TRUE) = TRUE) = FALSE, ([not]([not](TRUE) = TRUE), ()): |- [not]([not](TRUE) = TRUE) = TRUE, ([not]([not](TRUE)), ()): |- [not]([not](TRUE)) = TRUE, (FALSE, ()): |- FALSE = FALSE, (-0, ()): |- (-0) = 0}</em><a class="headerlink" href="#proveit.logic.Equals.known_simplifications" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="staticmethod">
<dt id="proveit.logic.Equals.StrongRelationClass">
<em class="property">static </em><code class="descname">StrongRelationClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.StrongRelationClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.StrongRelationClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="proveit.logic.Equals.WeakRelationClass">
<em class="property">static </em><code class="descname">WeakRelationClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.WeakRelationClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.WeakRelationClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.affirmViaContradiction">
<code class="descname">affirmViaContradiction</code><span class="sig-paren">(</span><em>conclusion</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.affirmViaContradiction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.affirmViaContradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>From (A=FALSE), derive the conclusion provided that the negated conclusion
implies both (A=FALSE) as well as A, and the conclusion is a Boolean.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.applyTransitivity">
<code class="descname">applyTransitivity</code><span class="sig-paren">(</span><em>other</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.applyTransitivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.applyTransitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>From x = y (self) and y = z (other) derive and return x = z.
Also works more generally as long as there is a common side to the equations.
If “other” is not an equality, reverse roles and call ‘applyTransitivity’
from the “other” side.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.conclude">
<code class="descname">conclude</code><span class="sig-paren">(</span><em>assumptions</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.conclude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.conclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to conclude the equality various ways:
simple reflexivity (x=x), via an evaluation (if one side is an
irreducible), or via transitivity.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.concludeBooleanEquality">
<code class="descname">concludeBooleanEquality</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.concludeBooleanEquality"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.concludeBooleanEquality" title="Permalink to this definition">¶</a></dt>
<dd><p>Prove and return self of the form (A=TRUE) assuming A, A=FALSE assuming Not(A), [Not(A)=FALSE] assuming A.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.concludeViaReflexivity">
<code class="descname">concludeViaReflexivity</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.concludeViaReflexivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.concludeViaReflexivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Prove and return self of the form x = x.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deduceInBool">
<code class="descname">deduceInBool</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deduceInBool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deduceInBool" title="Permalink to this definition">¶</a></dt>
<dd><p>Deduce and return that this equality statement is in the set of Booleans.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deduceNegated">
<code class="descname">deduceNegated</code><span class="sig-paren">(</span><em>i</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deduceNegated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deduceNegated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deduceNotEquals">
<code class="descname">deduceNotEquals</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deduceNotEquals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deduceNotEquals" title="Permalink to this definition">¶</a></dt>
<dd><p>Deduce x != y assuming not(x = y), where self is x=y.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.denyViaContradiction">
<code class="descname">denyViaContradiction</code><span class="sig-paren">(</span><em>conclusion</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.denyViaContradiction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.denyViaContradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>From (A=FALSE), derive the negated conclusion provided that the conclusion
implies both (A=FALSE) as well as A, and the conclusion is a Boolean.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveContradiction">
<code class="descname">deriveContradiction</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveContradiction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveContradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>From A=FALSE, and assuming A, derive FALSE.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveIsInSingleton">
<code class="descname">deriveIsInSingleton</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveIsInSingleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveIsInSingleton" title="Permalink to this definition">¶</a></dt>
<dd><p>From (x = y), derive (x in {y}).</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveLeftViaEquivalence">
<code class="descname">deriveLeftViaEquivalence</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveLeftViaEquivalence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveLeftViaEquivalence" title="Permalink to this definition">¶</a></dt>
<dd><p>From A = B, derive A (the Right-Hand-Side) assuming B.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveReversed">
<code class="descname">deriveReversed</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveReversed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveReversed" title="Permalink to this definition">¶</a></dt>
<dd><p>From x = y derive y = x.  This derivation is an automatic side-effect.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveRightViaEquivalence">
<code class="descname">deriveRightViaEquivalence</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveRightViaEquivalence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveRightViaEquivalence" title="Permalink to this definition">¶</a></dt>
<dd><p>From A = B, derive B (the Right-Hand-Side) assuming A.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.deriveViaBooleanEquality">
<code class="descname">deriveViaBooleanEquality</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.deriveViaBooleanEquality"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.deriveViaBooleanEquality" title="Permalink to this definition">¶</a></dt>
<dd><p>From A = TRUE derive A, or from A = FALSE derive Not(A).  This derivation
is an automatic side-effect.
Note, see deriveStmtEqTrue or Not.equateNegatedToFalse for the reverse process.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.evaluation">
<code class="descname">evaluation</code><span class="sig-paren">(</span><em>assumptions=None</em>, <em>automation=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.evaluation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.evaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given operands that may be evaluated to irreducible values that
may be compared, or if there is a known evaluation of this
equality, derive and return this expression equated to
TRUE or FALSE.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="proveit.logic.Equals.invert">
<em class="property">static </em><code class="descname">invert</code><span class="sig-paren">(</span><em>lambda_map</em>, <em>rhs</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.invert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Given some x -&gt; f(x) map and a right-hand-side, find the
x for which f(x) = rhs amongst known equalities under the
given assumptions.  Return this x if one is found; return
None otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.knownRelationsFromLeft">
<code class="descname">knownRelationsFromLeft</code><span class="sig-paren">(</span><em>assumptionsSet</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.knownRelationsFromLeft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.knownRelationsFromLeft" title="Permalink to this definition">¶</a></dt>
<dd><p>For each KnownTruth that is an Equals involving the given expression on
the left hand side, yield the KnownTruth and the right hand side.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="proveit.logic.Equals.knownRelationsFromRight">
<em class="property">static </em><code class="descname">knownRelationsFromRight</code><span class="sig-paren">(</span><em>expr</em>, <em>assumptionsSet</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.knownRelationsFromRight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.knownRelationsFromRight" title="Permalink to this definition">¶</a></dt>
<dd><p>For each KnownTruth that is an Equals involving the given expression on
the right hand side, yield the KnownTruth and the left hand side.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.negationSideEffects">
<code class="descname">negationSideEffects</code><span class="sig-paren">(</span><em>knownTruth</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.negationSideEffects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.negationSideEffects" title="Permalink to this definition">¶</a></dt>
<dd><p>Side-effect derivations to attempt automatically for a negated
equation.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.otherSide">
<code class="descname">otherSide</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.otherSide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.otherSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ‘other’ side of the of the equation if the given expr is on one side.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.reversed">
<code class="descname">reversed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.reversed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.reversed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Equals expression with the right side and left side reversed
from this one.  This is not a derivation: see deriveReversed().</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.sideEffects">
<code class="descname">sideEffects</code><span class="sig-paren">(</span><em>knownTruth</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.sideEffects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.sideEffects" title="Permalink to this definition">¶</a></dt>
<dd><p>Record the knownTruth in Equals.knownEqualities, associated from
the left hand side and the right hand side.  This information
may be useful for concluding new equations via transitivity. 
If the right hand side is an “irreducible value” (see 
isIrreducibleValue), also record it in
Equals.known_evaluation_sets for use when the evaluation
method is called.   Some side-effects derivations are also
attempted depending upon the form of this equality.
If the rhs is an “irreducible value” (see isIrreducibleValue),
also record the knownTruth in the Equals.known_simplifications
and Equals.known_evaluation_sets dictionaries, for use when the
simplification or evaluation method is called. The key for the
known_simplifications dictionary is the specific <em>combination</em>
of the lhs expression along with the assumptions in the form
(expr, tuple(sorted(assumptions))); the key for the
known_evaluation_sets dictionary is just the lhs expression
without the specific assumptions. Some side-effects
derivations are also attempted depending upon the form of this
equality.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.subLeftSideInto">
<code class="descname">subLeftSideInto</code><span class="sig-paren">(</span><em>lambda_map</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.subLeftSideInto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.subLeftSideInto" title="Permalink to this definition">¶</a></dt>
<dd><p>From x = y, and given P(y), derive P(x) assuming P(y).  
P(x) is provided via lambdaMap as a Lambda expression or an 
object that returns a Lambda expression when calling lambdaMap()
(see proveit.lambda_map, proveit.lambda_map.SubExprRepl in
particular), or, if neither of those, an expression to upon
which to perform a global replacement of self.rhs.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.subRightSideInto">
<code class="descname">subRightSideInto</code><span class="sig-paren">(</span><em>lambda_map</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.subRightSideInto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.subRightSideInto" title="Permalink to this definition">¶</a></dt>
<dd><p>From x = y, and given P(x), derive P(y) assuming P(x).  
P(x) is provided via lambdaMap as a Lambda expression or an 
object that returns a Lambda expression when calling lambdaMap()
(see proveit.lambda_map, proveit.lambda_map.SubExprRepl in
particular), or, if neither of those, an expression to upon
which to perform a global replacement of self.lhs.</p>
</dd></dl>

<dl class="method">
<dt id="proveit.logic.Equals.substitution">
<code class="descname">substitution</code><span class="sig-paren">(</span><em>lambda_map</em>, <em>assumptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/logic/equality/equals.html#Equals.substitution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.logic.Equals.substitution" title="Permalink to this definition">¶</a></dt>
<dd><p>From x = y, and given f(x), derive f(x)=f(y).
f(x) is provided via lambdaMap as a Lambda expression or an 
object that returns a Lambda expression when calling lambdaMap()
(see proveit.lambda_map, proveit.lambda_map.SubExprRepl in
particular), or, if neither of those, an expression to upon
which to perform a global replacement of self.lhs.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.asExpression.html">asExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.asExpressions.html">asExpressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.attempt_to_simplify.html">attempt_to_simplify</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.compositeExpression.html">compositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.expressionDepth.html">expressionDepth</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.indexed_var.html">indexed_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybeFenced.html">maybeFenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybeFencedLatex.html">maybeFencedLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybeFencedString.html">maybeFencedString</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.possibly_free_var_ranges.html">possibly_free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safeDefaultOrDummyVar.html">safeDefaultOrDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safeDummyVar.html">safeDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safeDummyVars.html">safeDummyVars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.singleOrCompositeExpression.html">singleOrCompositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.varRange.html">varRange</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Context.html">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ContextException.html">ContextException</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.DisallowedParameterRelabeling.html">DisallowedParameterRelabeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.HypotheticalReasoning.html">HypotheticalReasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.KnownTruth.html">KnownTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.OperationSequence.html">OperationSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransitiveSequence.html">TransitiveSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Variable.html">Variable</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.concludeViaImplication.html">concludeViaImplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.defaultSimplification.html">defaultSimplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.evaluateTruth.html">evaluateTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.inBool.html">inBool</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.isIrreducibleValue.html">isIrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.reduceOperands.html">reduceOperands</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Membership.html">Membership</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Nonmembership.html">Nonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotSupersetEq.html">NotSupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Subset.html">Subset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Superset.html">Superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SupersetEq.html">SupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Union.html">Union</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.GreaterEqOnlySeq.html">GreaterEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.GreaterOnlySeq.html">GreaterOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.LessEqOnlySeq.html">LessEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.LessOnlySeq.html">LessOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.const_shift_composition.html">const_shift_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.const_shift_decomposition.html">const_shift_decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.greaterSequence.html">greaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.isLiteralInt.html">isLiteralInt</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.lesserSequence.html">lesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.subtract.html">subtract</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Greater.html">Greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.GreaterEq.html">GreaterEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.GreaterSequence.html">GreaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.LesserSequence.html">LesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.number.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="proveit.logic.Distinct.html" title="previous chapter">Distinct</a></li>
      <li>Next: <a href="proveit.logic.EvaluationError.html" title="next chapter">EvaluationError</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/api/proveit.logic.Equals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>